<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Words of Luke Silva</title>
    <link>//localhost:1313/</link>
    <description>Recent content on Words of Luke Silva</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Mon, 29 Nov 2021 11:41:55 -0300</lastBuildDate><atom:link href="//localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Como usar Redis em uma solu√ß√£o .Net</title>
      <link>//localhost:1313/posts/dotnet-redis/</link>
      <pubDate>Mon, 29 Nov 2021 11:41:55 -0300</pubDate>
      
      <guid>//localhost:1313/posts/dotnet-redis/</guid>
      <description>&lt;p&gt;Ol√°!&lt;/p&gt;
&lt;p&gt;Faz algum tempo que n√£o escrevo por aqui mas senti saudades disso. Desde que escrevi meu √∫ltimo artigo grande (&lt;a href=&#34;https://dev.to/cephalopodluke/introducao-a-programacao-com-dart-aji&#34;&gt;uma introdu√ß√£o sobre flutter&lt;/a&gt;), comecei a trabalhar com .Net e C#. √â poss√≠vel ver algumas semelhan√ßas em ambas linguagens e isso facilitou bastante meu aprendizado nela.&lt;/p&gt;
&lt;p&gt;Bem, tenho desenvolvido algumas APIs e trabalhado com alguns problemas envolvendo implanta√ß√µes de aplica√ß√µes, bem coisa de backend mesmo. Um dos primeiros problemas que precisei resolver foi implementar uma forma de uso de cache utilizando Redis em uma API.&lt;/p&gt;</description>
      <content>&lt;p&gt;Ol√°!&lt;/p&gt;
&lt;p&gt;Faz algum tempo que n√£o escrevo por aqui mas senti saudades disso. Desde que escrevi meu √∫ltimo artigo grande (&lt;a href=&#34;https://dev.to/cephalopodluke/introducao-a-programacao-com-dart-aji&#34;&gt;uma introdu√ß√£o sobre flutter&lt;/a&gt;), comecei a trabalhar com .Net e C#. √â poss√≠vel ver algumas semelhan√ßas em ambas linguagens e isso facilitou bastante meu aprendizado nela.&lt;/p&gt;
&lt;p&gt;Bem, tenho desenvolvido algumas APIs e trabalhado com alguns problemas envolvendo implanta√ß√µes de aplica√ß√µes, bem coisa de backend mesmo. Um dos primeiros problemas que precisei resolver foi implementar uma forma de uso de cache utilizando Redis em uma API.&lt;/p&gt;
&lt;p&gt;Apenas para esclarecimento, cache √© um local de armazenamento de dados tempor√°rios que servir√£o para ajudar aplica√ß√µes web, mobile etc. Implementar cache na sua solu√ß√£o pode trazer diversos benef√≠cios como economizar banda, reduzir tempo de resposta, realizar menos chamadas ao banco em alguns casos espec√≠ficos etc. Entretanto tamb√©m pode causar in√∫meros problemas. Um deles √© o de os dados n√£o estarem mais atualizados em solu√ß√µes que esses dados mudam frequentemente.&lt;/p&gt;
&lt;p&gt;Criei um c√≥digo para esse artigo que pode ser encontrado &lt;a href=&#34;https://github.com/lukelima/ExemploRedis&#34;&gt;nesse reposit√≥rio do GitHub&lt;/a&gt;. Nele, criei consumi a &lt;a href=&#34;https://pokeapi.co/&#34;&gt;Pok√©Api&lt;/a&gt;, uma API com dados de quase todos os pok√©mons lan√ßados at√© hoje. Segui a pol√≠tica de fair use dela que diz &lt;em&gt;&amp;ldquo;Locally cache resources whenever you request them.&amp;rdquo;&lt;/em&gt; (armazene recursos em cache quando os consultar) e salvei todas as requisi√ß√µes em cache por um tempo limitado.&lt;/p&gt;
&lt;p&gt;A estrutura de pastas do projeto ficou da seguinte forma:za&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExemploRedis/
‚îú‚îÄ Controllers/
‚îÇ  ‚îú‚îÄ PokemonController.cs
‚îú‚îÄ Extensions/
‚îÇ  ‚îú‚îÄ DistributedCacheExtension.cs
‚îú‚îÄ Services/
‚îÇ  ‚îú‚îÄ Interfaces/
‚îÇ  ‚îÇ  ‚îú‚îÄ ICacheService.cs
‚îÇ  ‚îÇ  ‚îú‚îÄ IPokemonService.cs
‚îÇ  ‚îú‚îÄ PokemonCacheService.cs
‚îÇ  ‚îú‚îÄ PokemonService.cs
‚îú‚îÄ Pokemon.cs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O arquivo &lt;strong&gt;Pokemon.cs&lt;/strong&gt; cont√©m as informa√ß√µes de Pok√©mons da API. Para a simplicidade do exemplo, adicionei apenas 3 propriedades:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Pokemon
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Weight { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Adicionei o pacote &lt;strong&gt;Microsoft.Extensions.Caching.Redis&lt;/strong&gt; NuGet para trabalhar com o Redis. Com ele, criei a extens√£o &lt;strong&gt;Extensions/DistributedCacheExtension.cs&lt;/strong&gt; para adicionar o servi√ßo √† API:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public static IServiceCollection AddDistributedCache(
    this IServiceCollection services,
    IConfiguration configuration)
{
    services.AddDistributedRedisCache(options =&amp;gt;
    {
        options.Configuration = 
            configuration.GetConnectionString(&amp;#34;Redis&amp;#34;);
        options.InstanceName = 
            configuration[&amp;#34;Redis:InstanceName&amp;#34;];
    });
    return services;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As options da configura√ß√£o s√£o autoexplicativas: string de conex√£o ao servi√ßo e nome da inst√¢ncia.
Adicionei essa extens√£o no arquivo Startup.cs, no m√©todo &lt;strong&gt;ConfigureServices&lt;/strong&gt;, com a seguinte linha de c√≥digo:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;services.AddDistributedCache(Configuration);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Com o Redis configurado, desenvolvi um servi√ßo que me auxiliaria a buscar e adicionar dados a ele visando evitar repeti√ß√£o de c√≥digo.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public interface ICacheService&amp;lt;T&amp;gt;
{
    Task&amp;lt;T&amp;gt; Get(int id);
    Task Set(T content);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O c√≥digo acima √© da interface do servi√ßo. Decidi usar um tipo gen√©rico nela para que ela seja reaproveitada para qualquer objeto que eu precisar. O servi√ßo que a implementa ficou assim:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class PokemonCacheService : ICacheService&amp;lt;Pokemon&amp;gt;
{
    private readonly IDistributedCache _distributedCache;
    private readonly DistributedCacheEntryOptions _options;
    private const string Prefix = &amp;#34;pokemon_&amp;#34;;

    public PokemonCacheService(IDistributedCache distributedCache)
    {
        _distributedCache = distributedCache;
        _options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = 
                TimeSpan.FromSeconds(120),
            SlidingExpiration = TimeSpan.FromSeconds(60)
        };
    }

    public async Task&amp;lt;Pokemon&amp;gt; Get(int id)
    {
        var key = Prefix + id;
        var cache = await _distributedCache.GetStringAsync(key);
        if (cache is null)
        {
            return null;
        }
        var pokemon = JsonConvert.DeserializeObject&amp;lt;Pokemon&amp;gt; 
            (cache);
        return pokemon;
    }

    public async Task Set(Pokemon content)
    {
        var key = Prefix + content.Id;
        var pokemonString = JsonConvert.SerializeObject(content);
        await _distributedCache.SetStringAsync(key, pokemonString, 
            _options);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Passando por todos os pontos:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private readonly IDistributedCache _distributedCache;
private readonly DistributedCacheEntryOptions _options;
private const string Prefix = &amp;#34;pokemon_&amp;#34;;

public PokemonCacheService(IDistributedCache distributedCache)
{
    _distributedCache = distributedCache;
    _options = new DistributedCacheEntryOptions
    {
        AbsoluteExpirationRelativeToNow =   
            TimeSpan.FromSeconds(120),
        SlidingExpiration = TimeSpan.FromSeconds(60)
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Os dois primeiros campos, &lt;strong&gt;_distributedCache&lt;/strong&gt; e &lt;strong&gt;_options&lt;/strong&gt; est√£o relacionados diretamente √† configura√ß√£o do Redis. &lt;strong&gt;IDistributedCache&lt;/strong&gt; √© a interface que utilizei para acessar o Redis atrav√©s de inje√ß√£o de depend√™ncia. J√° &lt;strong&gt;DistributedCacheEntryOptions&lt;/strong&gt; √© a classe respons√°vel por configurar op√ß√µes como &lt;strong&gt;AbsoluteExpirationRelativeToNow&lt;/strong&gt; e &lt;strong&gt;SlidingExpiration&lt;/strong&gt;, que referem-se ao tempo total que um dado ficar√° armazenado e ao tempo que ele pode ficar armazenado sem ser consultado (nunca maior que o tempo absoluto), respectivamente. &lt;strong&gt;Prefix&lt;/strong&gt; refere-se ao prefixo que utilizo para armazenar os pokemons. Utilizo ele + o id do pokemon para armazenar os dados com chaves √∫nicas &amp;ndash; o que facilita a consulta posterior.&lt;/p&gt;
&lt;p&gt;Sobre o m√©todo Get:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public async Task&amp;lt;Pokemon&amp;gt; Get(int id)
{
    var key = Prefix + id;
    var cache = await _distributedCache.GetStringAsync(key);
    if (cache is null)
    {
        return null;
    }
    var pokemon = JsonConvert.DeserializeObject&amp;lt;Pokemon&amp;gt;(cache);
    return pokemon;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nele, crio a chave como prefixo + id do pokemon e busco o dado no cache utilizando o m√©todo &lt;strong&gt;GetStringAsync(key)&lt;/strong&gt; da interface IDistributedCache. Se ele for nulo, retorno nulo (ou poderia notificar um erro ou lan√ßar uma exce√ß√£o). Caso o contr√°rio, deserializo a string obtida em pokemon e retorno o valor.&lt;/p&gt;
&lt;p&gt;Sobre o m√©todo Set:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public async Task Set(Pokemon content)
{
    var key = Prefix + content.Id;
    var pokemonString = JsonConvert.SerializeObject(content);
    await _distributedCache.SetStringAsync(key, pokemonString, 
        _options);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nele, crio a chave da mesma forma, com o prefixo + o id do pokemon informado, ent√£o serializo o objeto em string e armazeno no Redis utilizando o m√©todo &lt;strong&gt;SetStringAsync()&lt;/strong&gt; da interface IDistributedCache. Esse m√©todo recebe a chave que ser√° utilizada para armazenamento (a mesma a ser consultada depois), o dado que ser√° armazenado e as op√ß√µes de armazenamento (lembra que configurei a expira√ß√£o dos dados no construtor ? Pois bem, √© aqui que informo essa configura√ß√£o).&lt;/p&gt;
&lt;p&gt;Com o servi√ßo de cache pronto, desenvolvi o servi√ßo de consulta √† Pok√©Api. Interface:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public interface IPokemonService
{
    Task&amp;lt;Pokemon&amp;gt; GetPokemon(int id);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;E o servi√ßo que a implementa:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class PokemonService : IPokemonService
{
    private readonly HttpClient _httpClient;

    public PokemonService(HttpClient httpClient)
    {
        _httpClient = httpClient;
        _httpClient.BaseAddress = new 
            Uri(&amp;#34;https://pokeapi.co/api/v2/&amp;#34;);
    }

    public async Task&amp;lt;Pokemon&amp;gt; GetPokemon(int id)
    {
        var response = await 
            _httpClient.GetAsync($&amp;#34;pokemon/{id}&amp;#34;);
        var content = await response.Content.ReadAsStringAsync();
        var pokemon = JsonConvert.DeserializeObject&amp;lt;Pokemon&amp;gt; 
            (content);
        return pokemon;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O servi√ßo √© bem simples: possui um campo HttpClient que foi injetado e o m√©todo GetPokemon(int id), que faz a chamada √† API e retorna um pok√©mon. Adicionei o HttpClient ao startup utilizando a seguinte linha de c√≥digo no arquivo &lt;strong&gt;Startup.cs&lt;/strong&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    services.AddHttpClient&amp;lt;IPokemonService, PokemonService&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;√â importante notar que esse m√©todo adiciona tanto o client como o servi√ßo a ser injetado por depend√™ncia.&lt;/p&gt;
&lt;p&gt;Com tudo pronto, criei um controller para servir esses dados:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[ApiController]
[Route(&amp;#34;api/[controller]&amp;#34;)]
public class PokemonController : ControllerBase
{
    private readonly IPokemonService _pokemonService;
    private readonly ICacheService&amp;lt;Pokemon&amp;gt; _pokemonCacheService;

    public PokemonController(IPokemonService pokemonService, 
        ICacheService&amp;lt;Pokemon&amp;gt; pokemonCacheService)
    {
        _pokemonService = pokemonService;
        _pokemonCacheService = pokemonCacheService;
    }

    [HttpGet(&amp;#34;{id}&amp;#34;)]
    public async Task&amp;lt;IActionResult&amp;gt; Get(int id)
    {
        Pokemon pokemon = await _pokemonCacheService.Get(id);
        if (pokemon is null)
        {
            pokemon = await _pokemonService.GetPokemon(id);
            await _pokemonCacheService.Set(pokemon);
        }
        return Ok(pokemon);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nele, injeto tanto o PokemonService quanto o CacheService pelo construtor. Como essa Api faz apenas a pesquisa de pokemons, o controller possui apenas 1 m√©todo: Get. Ele recebe um id na rota, ent√£o verifica se h√° no cache um pokemon com esse id. Se houver, ele retorna o pok√©mon. Caso n√£o haja, ele chama o service que consultar√° a API e ent√£o devolve o pok√©mon.&lt;/p&gt;
&lt;p&gt;E esse √© o fim do tutorial. Lembre-se de baixar o reposit√≥rio no &lt;a href=&#34;https://github.com/lukelima/ExemploRedis&#34;&gt;GitHub&lt;/a&gt; caso queira estud√°-lo melhor. Caso queira, deixei um arquivo docker-compose.yml para facilitar o uso do Redis.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Introducao √† programacao com Dart</title>
      <link>//localhost:1313/posts/introducao-programacao-com-dart/</link>
      <pubDate>Mon, 06 Jan 2020 10:58:10 -0300</pubDate>
      
      <guid>//localhost:1313/posts/introducao-programacao-com-dart/</guid>
      <description>&lt;p&gt;Tenho trabalhado com Flutter h√° aproximadamente um ano e queria compartilhar tudo que aprendi de algum forma. Entretanto, n√£o adianta falar sobre o framework se as pessoas n√£o conhecem a linguagem por tr√°s dele. Al√©m disso, sinto falta de conte√∫dos voltados aos iniciantes. Assim sendo, decidi unir o √∫til ao agrad√°vel e criar essa pequena introdu√ß√£o üòä&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;N√£o se preocupe caso n√£o entenda algum termo no in√≠cio: todos eles (ou a maioria) ser√£o explicados ao longo do texto. Caso fique alguma d√∫vida, escreva um coment√°rio ou me mande um tweet&lt;/strong&gt;&lt;/p&gt;</description>
      <content>&lt;p&gt;Tenho trabalhado com Flutter h√° aproximadamente um ano e queria compartilhar tudo que aprendi de algum forma. Entretanto, n√£o adianta falar sobre o framework se as pessoas n√£o conhecem a linguagem por tr√°s dele. Al√©m disso, sinto falta de conte√∫dos voltados aos iniciantes. Assim sendo, decidi unir o √∫til ao agrad√°vel e criar essa pequena introdu√ß√£o üòä&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;N√£o se preocupe caso n√£o entenda algum termo no in√≠cio: todos eles (ou a maioria) ser√£o explicados ao longo do texto. Caso fique alguma d√∫vida, escreva um coment√°rio ou me mande um tweet&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Essa postagem est√° dispon√≠vel no &lt;a href=&#34;https://github.com/lukelima/Flutter-tutoriais/blob/master/intoToDart.md&#34;&gt;meu GitHub&lt;/a&gt;. Caso haja algum erro, por favor, abra uma issue.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;dart---a-linguagem&#34;&gt;Dart - a linguagem&lt;/h2&gt;
&lt;p&gt;Criada em 2011 com foco inicial em desenvolvimento web, Dart √© uma linguagem puramente orientada a objetos, baseada em classes e de heran√ßa √∫nica. √â opcionalmente tipada pois dart suporta infer√™ncia de tipos (o interpretador tenta reconhec√™-los por si mesmo), e o tipo de cada objeto durante o tempo de execu√ß√£o √© uma inst√¢ncia da classe Type. (&lt;a href=&#34;https://dart.dev/guides/language/specifications/DartLangSpec-v2.2.pdf&#34;&gt;Especifica√ß√µes da linguagem&lt;/a&gt;). Isso quer dizer que tudo em Dart √© um objeto, que a linguagem √© fortemente baseada nas classes, o conceito fundamental da &lt;strong&gt;programa√ß√£o orientada a objetos&lt;/strong&gt;, e que voc√™ pode ou n√£o declarar o tipo da sua vari√°vel.&lt;/p&gt;
&lt;h3 id=&#34;motivos-para-usar-dart&#34;&gt;Motivos para usar dart&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Compila√ß√£o AoT - apps criados em dart s√£o compilados antes de serem executados, fazendo com que rodem de forma suave;&lt;/li&gt;
&lt;li&gt;sintaxe semelhante √†s linguagens baseadas em C. Se voc√™ desenvolve em java, n√£o ter√° muita dificuldade em migrar;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pub.dev/&#34;&gt;Pub&lt;/a&gt; - por mais que o gerenciados de pacotes ainda n√£o seja t√£o grande quanto o NPM, h√° v√°rios pacotes voltador √†s plataformas nas quais a roda;&lt;/li&gt;
&lt;li&gt;open source - sim, voc√™ pode contribui com a linguagem. &lt;a href=&#34;https://github.com/dart-lang&#34;&gt;Clique aqui&lt;/a&gt; para ter acesso aos reposit√≥rios no GitHub;&lt;/li&gt;
&lt;li&gt;anima√ß√µes a 60 FPS em flutter;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;instala√ß√£o&#34;&gt;Instala√ß√£o&lt;/h2&gt;
&lt;p&gt;N√£o √© necess√°rio instalar as ferramentas de desenvolvimento para acompanhar esta postagem pois os mantenedores da linguagem criaram o &lt;a href=&#34;https://dartpad.dev/&#34;&gt;DartPad&lt;/a&gt;, que permite testar c√≥digos Dart e criar aplicativos simples diretamente no seu navegador. Entretanto, caso deseje instalar, eis o passo-a-passo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clique em &lt;a href=&#34;https://dart.dev/get-dart&#34;&gt;get dart&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;escolha o seu sistema operacional e digite os comandos no terminal ou baixe o gerenciador de instala√ß√£o;
Ap√≥s instalar as ferramentas para desenvolver em Dart voc√™ poder√° rodar arquivos .dart atrav√©s do terminal.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ides&#34;&gt;IDEs&lt;/h2&gt;
&lt;p&gt;IDEs, ou ambientes integrados de desenvolvimento, s√£o como editores de texto, mas com ferramentas espec√≠ficas para ajudar no desenvolvimento: autocomplete, verificador de sintaxe, debuggers etc. H√° v√°rios IDEs gratuitos. Os meus preferidos s√£o &lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;VSCode&lt;/a&gt;, &lt;a href=&#34;https://atom.io/&#34;&gt;Atom&lt;/a&gt; e &lt;a href=&#34;https://developer.android.com/studio&#34;&gt;Android Studio&lt;/a&gt;, por mais que o √∫ltimo seja um tanto pesado para computadores com poucos recursos de mem√≥ria e processamento.&lt;/p&gt;
&lt;h2 id=&#34;vari√°veis&#34;&gt;Vari√°veis&lt;/h2&gt;
&lt;p&gt;Vari√°veis s√£o como caixinhas que armazenam um valor na mem√≥ria. Em vez de utilizar o c√≥digo hexadecimal correspondente ao lugar dessas caixinhas na mem√≥ria (o endere√ßo delas), √© poss√≠vel nome√°-las, facilitando o uso dos dados que elas cont√©m.
Imagine que voc√™ precise somar o sal√°rio de todos os gastos de uma papelaria qualquer, e que para isso, apenas jogue os n√∫meros em um papel (ou calculadora) a partir dos valores encontrados nos recibos&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;       1000
       1500
       2000
       1000
       1250
       1000
       1300
       1500
total: 10550
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Agora imagine que daqui a 1 ano os recibos tenham se apagado e voc√™, por alguma raz√£o, precise achar o valor que foi gasto com cadernos. Olhando a conta acima, conseguiria ach√°-lo? N√£o seria mais simples se houvesse uma &amp;ldquo;legenda&amp;rdquo; dizendo a qu√™ se referem esses valores? Imagine a bagun√ßa conforme os anos se passarem&amp;hellip;
Declarar vari√°veis √© uma das opera√ß√µes fundamentais na programa√ß√£o. Em algumas linguagens, √© algo simples como&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pi = 3.14
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Em Dart, declar√°-las √© feito de forma parecida, apenas colocando a palavra &amp;ldquo;var&amp;rdquo; atr√°s dos nomes, ou o tipo delas na mesma posi√ß√£o&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var pi = 3.14;
// ou
double pi = 3.14;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tip√°-las previnir√° alguns erros futuros e facilitar√° seu trabalho com IDEs (ambientes de desenvolvimento integrados). Entretanto, as guidelines da linguagem indicam que para vari√°veis locais (como aquelas dentro de fun√ß√µes), √© prefer√≠vel o uso de &amp;ldquo;var&amp;rdquo;.
Caso queira que suas vari√°veis n√£o mudem, utilize a anota√ß√£o &amp;ldquo;const&amp;rdquo; ou &amp;ldquo;final&amp;rdquo; antes do tipo&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;final name = &amp;#39;Bob&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Em outras linguagens h√° uma forma de mudar o n√≠vel de acesso das vari√°veis, ou seja, mudar o quanto elas podem ser vistas de fora da classe. Essa forma se d√° atrav√©s da utiliza√ß√£o das palavras &amp;ldquo;protected&amp;rdquo;, &amp;ldquo;public&amp;rdquo; e &amp;ldquo;private&amp;rdquo;. Em dart, basta escrever &amp;ldquo;_&amp;rdquo; antes do nome delas para torn√°-las privadas.
H√° dois escopos para elas: local e global. O primeiro se refere √†quelas que s√£o declaradas dentro de fun√ß√µes e n√£o podem ser acessadas fora delas. O segundo, √†quelas que s√£o declaradas fora de fun√ß√µes e podem ser acessadas de qualquer lugar no c√≥digo.&lt;/p&gt;
&lt;h3 id=&#34;como-escolher-o-nome-de-uma-vari√°vel&#34;&gt;Como escolher o nome de uma vari√°vel&lt;/h3&gt;
&lt;p&gt;Ok, √© mais f√°cil trabalhar com o nome de uma vari√°vel do que com o endere√ßo na mem√≥ria (exemplo: 0x9cf10c). Por√©m n√£o pense que nome√°-las de qualquer jeito facilitar√° seu trabalho.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int a = 10;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O que significa &amp;ldquo;a&amp;rdquo; ? A qu√™ esse valor se refere ? Tudo bem, voc√™ pode saber o significado, mas e as pessoas que dar√£o manuten√ß√£o ao c√≥digo? &lt;strong&gt;O computador entender√° o que significa com ou sem nome. Todo c√≥digo escrito por voc√™ deve ser direcionado √†s pessoas que ler√£o ele, ent√£o facilite o trabalho delas üëç&lt;/strong&gt;.
Recomendo que leia o livro &lt;a href=&#34;https://www.amazon.com.br/C%C3%B3digo-limpo-Robert-C-Martin/dp/8576082675&#34;&gt;C√≥digo limpo&lt;/a&gt; para uma abordagem mais completa sobre o assunto.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A linguagem n√£o aceita que os nomes comecem por n√∫meros, nem que contenham espa√ßos em branco ou caracteres especiais(com exce√ß√£o de &amp;ldquo;$&amp;rdquo; e &amp;ldquo;_&amp;rdquo;), e muito menos que seja uma das &lt;a href=&#34;https://dart.dev/guides/language/language-tour#keywords&#34;&gt;palavras reservadas&lt;/a&gt; dela.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// errado
int 1Numero = 10;

//correto  
int umNumero = 10;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;algoritmos&#34;&gt;Algoritmos&lt;/h2&gt;
&lt;p&gt;√â um tanto clich√™ falar que algoritmos s√£o como receitas culin√°rias, mas s√£o mesmo: uma sequ√™ncia de instru√ß√µes para a execu√ß√£o de uma tarefa. Pense nos ingredientes como &amp;ldquo;vari√°veis&amp;rdquo;, e no modo de preparo como a execu√ß√£o do seu programa. Veja uma receita simples de brigadeiro (o m√°ximo que consigo fazer em uma cozinha ü§£):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ingredientes:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1 caixa de leite condensado;
3 colheres (sopa) de achocolatado;
1 colher (sopa) de manteiga;
1 x√≠cara (ch√°) de chocolate granulado
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Podemos dizer que o nome de cada ingrediente √© igual ao nome de uma vari√°vel, e que a quantidade dos ingredientes, o valor delas. Assim sendo:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int caixaDeLeiteCondensado = 1;
int colheresDeAchocolatado = 3;
int colherDeManteiga = 1;
int xicaraDeChocolateGranulado = 1
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Quanto ao modo de preparo:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1 - Adicione o leite condensado, o achocolatado e a manteiga em uma panela;
2 - misture em fogo baixo por 10 minutos;
3 - deixe esfriar em um prato untado;
4 - enrole a mistura e adicione granulado;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Em c√≥digo usando fun√ß√µes (√∫ltima sess√£o do artigo):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var mistura = adicionarNaPanela(caixaDeLeiteCondensado, colheresDeAchocolatado, colherDeManteiga);
misturarEmFogoBaixo(mistura);
deixarEsfriar(mistura, pratoUntado);
enrolarEGranular(mistura);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;√â claro, h√° v√°rios n√≠veis de complexidade para algoritmos de uma mesma tarefa: voc√™ pode dizer que come√ßa o dia levantando da cama, ou pode ser mais profundo e dizer que come√ßa abrindo os olhos, se espregui√ßando, levantando o tronco, sentando na cama&amp;hellip;
Algoritmos s√£o a base da programa√ß√£o. E pasme: voc√™ aprender√° sobre algumas ferramentas durante sua vida profissional, mas a maioria dos seus problemas iniciais ser√° resultante da falta de pr√°tica com algoritmos, n√£o com as ferramentas em si!&lt;/p&gt;
&lt;p&gt;**NUNCA SE ESQUE√áA DE UTILIZAR ; (PONTO E V√çRGULA) AO FINAL DE CADA INSTRU√á√ÉO&lt;/p&gt;
&lt;h2 id=&#34;coment√°rios&#34;&gt;Coment√°rios&lt;/h2&gt;
&lt;p&gt;Coment√°rios servem para escrever uma mensagem no c√≥digo que n√£o ser√° interpretada pelo computador. Essa mensagem costuma ser criada para documentar o c√≥digo (explic√°-lo), mas n√£o se engane: a necessidade de diversos coment√°rios pode ser indicativo de que a escolha dos nomes das vari√°veis e fun√ß√µes, ou o uso delas, n√£o est√° claro o suficiente. Um c√≥digo bem escrito deve falar por si s√≥.
Dart suporta 3 tipos de coment√°rios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;os de 1 √∫nica linha&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// esse √© um coment√°rio de linha √∫nica
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;os de m√∫ltiplas linhas&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/*
  Esse √© um coment√°rio em
  m√∫ltiplas linhas
*/
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;os de documenta√ß√£o&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/// coment√°rios de documenta√ß√£o podem come√ßar com 3 barras invertidas ou /**
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Boa parte dos resultados de instru√ß√µes neste texto foram escritos em coment√°rios na frente delas.&lt;/p&gt;
&lt;h2 id=&#34;tipos-de-dados&#34;&gt;Tipos de dados&lt;/h2&gt;
&lt;h3 id=&#34;strings&#34;&gt;Strings&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;String nome = &amp;#39;Lucas&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Strings s√£o as representa√ß√µes de frases, palavras, caracteres etc. Sempre que for necess√°rio armazenar uma das op√ß√µes citadas, declare uma string com as palavras dentro de aspas simples (&amp;rsquo;&amp;rsquo;) ou duplas(&amp;quot;&amp;quot;). Elas s√£o as respons√°veis por textos em interfaces de sites e aplicativos. Em &lt;strong&gt;flutter&lt;/strong&gt;, por exemplo, s√£o o tipo de dado esperado pelo widget Text()&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Text(&amp;#34;Digite o seu nome: &amp;#34;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;M√©todos s√£o blocos de c√≥digo na forma de fun√ß√µes (veja ao final da postagem) que facilitam o trabalho com dados de determinados tipos. Como exemplo para strings temos &amp;ldquo;toUpperCase()&amp;rdquo;, que transforma a string em letras mai√∫sculas, ou &amp;ldquo;split()&amp;rdquo;, que separa ela em uma lista de caracteres. Esse tipo tamb√©m conta com algumas propriedades, como &amp;ldquo;length&amp;rdquo;, que conta o n√∫mero de caracteres (espa√ßos em branco tamb√©m), que, como m√©todos, tamb√©m s√£o acessadas utilizando um &amp;ldquo;.&amp;rdquo; ap√≥s o nome da vari√°vel e o nome da propriedade em seguida&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;String meuNome = &amp;#34;Lucas&amp;#34;;
  
print(meuNome.toLowerCase()); // lucas
print(meuNome.toUpperCase()); // LUCAS
print(meuNome.length);        // 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;√â poss√≠vel concatenar duas ou mais strings, unindo-as uma √∫nica.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;String nome = &amp;#34;Lucas&amp;#34;;
String sobrenome = &amp;#34;Silva&amp;#34;;

print(nome + &amp;#39; &amp;#39; + sobrenome);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Repare no espa√ßo em branco entre as vari√°veis. Dart possui suporte √† interpola√ß√£o, que √© uma maneira de criar strings sem a necessidade do operador &amp;ldquo;+&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;$variavel&amp;rdquo; para express√µes simples&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;String nome = &amp;#34;Lucas&amp;#34;;
String sobrenome = &amp;#34;Silva&amp;#34;;
print(&amp;#34;$nome $sobrenome&amp;#34;); // Lucas Silva
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&amp;ldquo;${variavel.metodo}&amp;rdquo; para express√µes mais complexas&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;String nome = &amp;#34;Lucas&amp;#34;;
String sobrenome = &amp;#34;Silva&amp;#34;;
print(&amp;#34;${nome.toUpperCase()} $sobrenome&amp;#34;); // LUCAS Silva
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;n√∫meros&#34;&gt;N√∫meros&lt;/h3&gt;
&lt;p&gt;Dizem que ci√™ncias da computa√ß√£o requerem muita matem√°tica. &lt;em&gt;√â e n√£o √© verdade&lt;/em&gt;. N√£o precisa ser doutor em matem√°tica para saber programar, mas n√£o deixar√° os n√∫meros de lado.
Voc√™ pode ter ouvido falar que os computadores entendem c√≥digos bin√°rios e tal. Esse tipo de abordagem aos n√∫meros (&amp;ldquo;bin√°rios&amp;rdquo;) se refere √† base deles. Podemos utilizar bin√°rios, hexadecimais (muito utilizados em cores), octais, decimais etc.
Os n√∫meros possuem basicamente dois tipos: os inteiros e os decimais. O primeiro tipo √© comumente chamado de &amp;ldquo;int&amp;rdquo;. O segundo, em algumas linguagens, √© chamado de &amp;ldquo;float&amp;rdquo; enquanto em outras, como  dart, √© chamado de &amp;ldquo;double&amp;rdquo;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int umNumero = 10;
double pi = 3.14;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;V√°rias opera√ß√µes matem√°ticas est√£o dispon√≠veis para esse tipo de dados. Arredondamento, M√°ximo divisor comum, checar se um n√∫mero √© par ou √≠mpar etc.&lt;/p&gt;
&lt;h3 id=&#34;boolean&#34;&gt;Boolean&lt;/h3&gt;
&lt;p&gt;√â um tipo de dados que representa 1 ou 0, sendo esses verdadeiro ou falso, respectivamente (embora essa correspond√™ncia n√£o seja v√°lida em Dart). Possui esse nome em homenagem a George Boole, que definiu um sistema de l√≥gica alg√©brica. S√£o muito utilizados em express√µes, principalmente as condicionais.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bool verdade = true;
bool mentira = false;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;listas&#34;&gt;Listas&lt;/h3&gt;
&lt;p&gt;√â dif√≠cil falar que algum tipo de dado √© mais importante que o outro, mas s√©rio, aprenda &lt;strong&gt;tudo&lt;/strong&gt; sobre listas. Saber manipular dados corretamente √© o primeiro passo para conseguir um emprego na √°rea.
Por mais que o interpretador consiga entender o tipo, √© sempre interessante tipar suas vari√°veis para evitar erros. Logo, listas se declarariam da seguinte forma:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;int&amp;gt; listaDeNumeros = [1, 2, 3];
List&amp;lt;String&amp;gt; vogais = [&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Listas s√£o como cole√ß√µes de valores. As notifica√ß√µes de um usu√°rio no Instagram, por exemplo, s√£o listas de objetos chamados Notifica√ß√µes (veremos sobre Programa√ß√£o orientada a objetos na pr√≥xima postagem). A famosa lista de tarefas (todo List) √© uma lista de&amp;hellip; adivinha? Tarefas!
J√° utilizou Todoist ? Pense assim:
O app √© basicamente uma lista. Nessa lista, √© poss√≠vel adicionar e remover tarefas. Essas opera√ß√µes s√£o feitas em Dart utilizando &amp;ldquo;add()&amp;rdquo;/&amp;ldquo;insert()&amp;rdquo; e remove(). O legal √© que insert pode utilizar o index do novo elemento, e √© poss√≠vel procurar diretamente pelo elemento a ser removido no remove. Tamb√©m √© poss√≠vel remover todas as tarefas da lista utilizando &amp;ldquo;clear()&amp;rdquo;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; vogais = [&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;];
vogais.add(&amp;#39;r&amp;#39;); // [&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;r&amp;#39;]
vogais.remove(&amp;#39;r&amp;#39;); // [&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;]
vogais.remove(&amp;#39;e&amp;#39;); // [&amp;#39;a&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;]
vogais.insert(1, &amp;#39;e&amp;#39;); //[&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;]
vogais.clear(); // [] &amp;lt;- lista vazia
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Index, ou √≠ndices, s√£o as posi√ß√µes dos elementos em uma lista. Na maioria das linguagens a contagem come√ßa por 0. Nunca se esque√ßa disso!
Adicionar uma lista √† outra se tornou mais simples a partir da vers√£o 2.3 da linguagem, na qual introduziu-se o &amp;ldquo;spread operator&amp;rdquo;. Caso o valor √† direita possa ser null, utilize o null-aware spread operator (√∫ltima linha do c√≥digo) para evitar erros na execu√ß√£o do c√≥digo.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;int&amp;gt; lista1 = [4, 5];
List&amp;lt;int&amp;gt; lista2 = [1, 2, 3, ...lista1]; // spread operator -&amp;gt;...lista1 copia os elementos
List&amp;lt;int&amp;gt; lista3 = [...?lista2]; // null-aware spread operator 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Outras novidades s√£o &amp;ldquo;collection if&amp;rdquo; e &amp;ldquo;collection for&amp;rdquo;, onde as listas s√£o criadas atrav√©s de uma condi√ß√£o ou de um loop.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/// collection if
List&amp;lt;String&amp;gt; listaDeCompras = [&amp;#39;chocolate&amp;#39;, &amp;#39;refrigerante&amp;#39;, if(estiveremEmPromocao)];

// collection for
List&amp;lt;int&amp;gt; primeiraListaDeNumeros = [3, 4, 5, 6];
List&amp;lt;int&amp;gt; segundaListaDeNumeros = [1, 2, for(int numero in primeiraListaDeNumeros) numero];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Uma propriedade √∫til das listas √© &amp;ldquo;length&amp;rdquo;, que retorna o n√∫mero de elementos dentro delas.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;int&amp;gt; listaDeNumeros = [1, 2, 3];
print(listaDeNumeros.length); // 3
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;conjuntos-sets&#34;&gt;Conjuntos (Sets)&lt;/h3&gt;
&lt;p&gt;Conjuntos em Dart s√£o como conjuntos matem√°ticos: a ordem e a quantidade de vezes que um elemento aparece n√£o possuem import√¢ncia. Para utiliz√°-los, √© necess√°rio colocar um tipo antes de {}. Caso contr√°rio, o interpretador entender√° que se trata de um Map.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var conjuntoDeNumeros = &amp;lt;int&amp;gt;{};
print(conjuntoDeNumeros is Set); // true

var outroConjuntoDeNumeros = {};
print(outroConjuntoDeNumeros is Set); // false

var letras = &amp;lt;String&amp;gt;{&amp;#39;a&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;c&amp;#39;};
print(letras); // {a, b, c}, pois elementos repetidos n√£o importam para conjuntos
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;mapas&#34;&gt;Mapas&lt;/h3&gt;
&lt;p&gt;Mapas s√£o objetos que associam chaves, em strings, a valores que podem ser de qualquer tipo! Apesar dos valores poderem se repetir, as chaves devem ser √∫nicas.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Map&amp;lt;String, dynamic&amp;gt; listaDeCompras = {
    &amp;#39;chocolates&amp;#39;: 2,
    &amp;#39;refrigerantes&amp;#39;: 4,
    &amp;#39;carne&amp;#39;: 1.5 // quilos
};

// Ou atrav√©s do construtor Map()
var listaDeCompras = Map();
listaDeCompras[&amp;#39;chocolates&amp;#39;] = 2;
listaDeCompras[&amp;#39;refrigerantes&amp;#39;] = 4;
listaDeCompras[&amp;#39;carne&amp;#39;] = 1.5;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Os valores de um mapa podem ser acessados da mesma forma que constru√≠mos a vari√°vel com o construtor Map():&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(listaDeCompras[&amp;#39;chocolates&amp;#39;]); // 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;S√£o utilizados na constru√ß√£o de objetos a partir de &lt;strong&gt;dados fornecidos por uma API ou query&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;runas&#34;&gt;Runas&lt;/h3&gt;
&lt;p&gt;Strings em Dart s√£o uma sequ√™ncia de caracteres Unicode no formato UTF-16. Um caractere unicode √© escrito da seguinte forma:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;\u2665    // ‚ô•
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As runas exp√µe o unicode de um string e podem ser usadas para formar caracteres especiais como s√≠mbolos e emojis.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Runes coracao = Runes(&amp;#39;\u2665&amp;#39;);
print(String.fromCharCodes(coracao)); // ‚ô•
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;s√≠mbolos&#34;&gt;S√≠mbolos&lt;/h3&gt;
&lt;p&gt;S√≠mbolos s√£o nomes (strings) utilizados para refletir metadados de uma biblioteca de c√≥digos ou API. Essas informa√ß√µes costumam ser otimizadas para que o computador as interprete, e os s√≠mbolos servem para torn√°-las mais leg√≠vel para n√≥s, humanos. Nome de classes, m√©todos e libs podem ser s√≠mbolos.
Confesso que n√£o vejo a utiliza√ß√£o deles com frequ√™ncia e os exemplos em rela√ß√£o a eles s√£o quase sempre iguais a esse aqui:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.w3adda.com/dart-tutorial/dart-symbol&#34;&gt;Dart Symbol&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dynamic&#34;&gt;Dynamic&lt;/h3&gt;
&lt;p&gt;Essa √© uma declara√ß√£o respons√°vel por permitir que qualquer valor seja atribuido a uma vari√°vel. √â prefer√≠vel declarar uma vari√°vel com dynamic do que deixar a infer√™ncia falhar. Entretanto √© recomendado utilizar &amp;ldquo;Object&amp;rdquo; em vez dele, deixando-o para quando for necess√°rio dinamismo em uma parte do programa ou quando os valores vir√£o de uma interoperabilidade entre JS/Kotlin, por exemplo.&lt;/p&gt;
&lt;h2 id=&#34;operadores&#34;&gt;Operadores&lt;/h2&gt;
&lt;p&gt;Operadores s√£o como os sinais matem√°ticos: pegam dois ou mais valores e transformam em um resultado diferente. H√° diversos tipos de operadores, ent√£o o uso deles n√£o se restringe a n√∫meros. Vimos, por exemplo, a concatena√ß√£o de strings utilizando o sinal &amp;ldquo;+&amp;rdquo;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(&amp;#34;Hello&amp;#34; + &amp;#34; World!&amp;#34;); // Hello World!
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;operadores-aritm√©ticos&#34;&gt;Operadores aritm√©ticos&lt;/h3&gt;
&lt;p&gt;S√£o os mesmos que utilizamos em contas. Considere:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;double umNumero = 10.0;
double outroNumero = 4.0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ent√£o:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ndash; soma dois valores (podendo ser strings);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero + outroNumero); // 14
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ndash; subtrai o segundo valor do primeiro;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero - outroNumero); // 6
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ndash; multiplica ambos os valores;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero * outroNumero); // 40
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;/ &amp;ndash; divide o primeiro valor pelo segundo;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero / outroNumero); // 2.5
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;~/ &amp;ndash; divide o primeiro valor pelo segundo mas retorna um n√∫mero inteiro, sem parte fracionada;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero ~/ outroNumero); // 2
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;% &amp;ndash; divide o primeiro valor pelo segundo e retorna o resto da divis√£o&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero % outroNumero); // 2, pois 10 / 4 = 8, com resto = 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A ordem de preced√™ncia pode ser consultada &lt;a href=&#34;https://dart.dev/guides/language/language-tour#operators&#34;&gt;nessa tabela&lt;/a&gt;, mas pode ser alterada usando par√™nteses &amp;ldquo;()&amp;rdquo;, como em contas matem√°ticas.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1 + 2 * 3 

√© diferente de

(1 + 2) * 3
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;operadores-de-incremento&#34;&gt;Operadores de incremento&lt;/h3&gt;
&lt;p&gt;S√£o aqueles que aumentam ou diminuem a vari√°vel em 1. S√£o divididos em dois tipos: prefixo, que aumenta a vari√°vel e depois avalia a express√£o, e &lt;em&gt;postfix&lt;/em&gt; (como um sufixo), que s√≥ aumenta a vari√°vel ap√≥s avaliar a express√£o&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Postfix:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;variavel++;
variavel--;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Prefixo:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;++variavel;
--variavel;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;operadores-de-igualdade-e-relacionais&#34;&gt;Operadores de igualdade e relacionais&lt;/h3&gt;
&lt;p&gt;S√£o aqueles usados para comparar valores. Considere:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;double umNumero = 10.0;
double outroNumero = 4.0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ent√£o:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;== &amp;ndash; retorna true se os valores forem iguais e falso se forem diferentes;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero == outroNumero); // false
print(umNumero == umNumero); // true
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;!= &amp;ndash; retorna true se os valores forem diferentes;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero != outroNumero); // true
print(umNumero != umNumero); // false
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ndash; retorna true se o primeiro valor for maior que o segundo;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero &amp;gt; outroNumero); // true
print(outroNumero &amp;gt; umNumero); // false
print(umNumero &amp;gt; umNumero); // false
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&amp;lt;  &amp;ndash; retorna true se o primeiro valor for menor que o segundo;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero &amp;lt; outroNumero); // false
print(outroNumero &amp;lt; umNumero); // true
print(umNumero &amp;lt; umNumero); // false
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;= &amp;ndash; retorna true se o primeiro valor for maior ou igual ao segundo;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero &amp;gt;= outroNumero); // true
print(outroNumero &amp;gt;= umNumero); // false
print(umNumero &amp;gt;= umNumero); // true, pois os n√∫meros s√£o iguais
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&amp;lt;= &amp;ndash; retorna true se o primeiro valor for menor ou igual ao segundo;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(umNumero &amp;lt;= outroNumero); // false
print(outroNumero &amp;lt;= umNumero); // true
print(umNumero &amp;lt;= umNumero); // true, pois os n√∫meros s√£o iguais
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;operadores-de-teste-de-tipos&#34;&gt;Operadores de teste de tipos&lt;/h3&gt;
&lt;p&gt;S√£o √∫teis para converter ou checar tipos de dados. Considere:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int num = 10;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;as  &amp;mdash; converte o tipo de um objeto. Pode ser utilizado como uma vers√£o enxuta do operador &amp;ldquo;is&amp;rdquo;;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if (emp is Person) {
  // Type check
  emp.firstName = &amp;#39;Bob&amp;#39;;
}

// com o operador &amp;#34;as&amp;#34;
(emp as Person).firstName = &amp;#39;Bob&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;is  &amp;mdash; retorna true se o valor for de um determinado tipo;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(num is int); // true
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;is! &amp;mdash; retorna true se o valor n√£o for de um determinado tipo;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(num is! String); // true
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;operadores-de-atribui√ß√£o&#34;&gt;Operadores de atribui√ß√£o&lt;/h3&gt;
&lt;p&gt;S√£o aqueles que atribuem valores √†s vari√°veis:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;=   &amp;mdash; utilizado para atribuir um valor a uma vari√°vel&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int umNumero = 2;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;+=  &amp;mdash; utilizado para somar um valor ao valor j√° existente na vari√°vel&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int umNumero = 2;
umNumero += 3;
print(umNumero); // 5, pois √© o mesmo que umNumero = umNumero + 3
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;-=  &amp;mdash; utilizado para subtrair um valor ao valor j√° existente na vari√°vel&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int umNumero = 2;
umNumero += 1;
print(umNumero); // 1
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;*=  &amp;mdash; utilizado para multiplicar um valor ao valor j√° existente na vari√°vel&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int umNumero = 2;
umNumero *= 2;
print(umNumero); // 4
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;/=  &amp;mdash; utilizado para dividir um valor ao valor j√° existente na vari√°vel&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;double umNumero = 2.0;
umNumero /= 2;
print(umNumero); // 1
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;~/= &amp;mdash; utilizado para dividir arredondando para baixo um valor ao valor j√° existente na vari√°vel&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int umNumero = 5;
umNumero ~/= 2;
print(umNumero); // 2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;operadores-l√≥gicos&#34;&gt;Operadores l√≥gicos&lt;/h3&gt;
&lt;p&gt;Servem para trabalhar com opera√ß√µes booleanas, que podem inverter ou n√£o o fluxo de execu√ß√£o de um programa.
Considere:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bool verdade = true;
bool mentira = false;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ent√£o:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;!express√£o &amp;mdash; inverte o valor da express√£o.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(!verdade); // false
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&amp;amp;&amp;amp; &amp;mdash; retorna true se ambas as express√µes forem verdadeiras.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(verdade &amp;amp;&amp;amp; verdade); // true
print(verdade &amp;amp;&amp;amp; mentira); // false
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;|| &amp;mdash; retorna true se uma das express√µes for verdadeira.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(verdade || verdade); // true
print(verdade || mentira); // true
print(mentira || mentira); // false
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;nota√ß√£o-de-cascata&#34;&gt;Nota√ß√£o de cascata&lt;/h3&gt;
&lt;p&gt;A ideia da nota√ß√£o de cascata √© evitar que seja necess√°ria a cria√ß√£o de vari√°veis tempor√°rias, permitindo o acesso a um mesmo objeto linha ap√≥s linha.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;querySelector(&amp;#39;#confirm&amp;#39;) // Pega um objeto
  ..text = &amp;#39;Confirm&amp;#39; // Usa as propriedades dele
  ..classes.add(&amp;#39;important&amp;#39;)
  ..onClick.listen((e) =&amp;gt; window.alert(&amp;#39;Confirmed!&amp;#39;));
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;outros-operadores&#34;&gt;Outros operadores&lt;/h3&gt;
&lt;p&gt;S√£o os respons√°veis por chamadas de fun√ß√£o e acesso a listas e propriedades de objetos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;() &amp;ndash; chamada de fun√ß√£o&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// definir a fun√ß√£o
void helloWorld() {
  print(&amp;#34;Hello World!&amp;#34;);
}

//chamar a fun√ß√£o
helloWorld();
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;[] &amp;ndash; acesso a elementos de lista&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;int&amp;gt; listaDeNumeros = [1, 2, 3, 4, 5];
int segundoNumeroDaLista = listaDeNumeros[1]; // pois os √≠ndices come√ßam por 0
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;.  &amp;ndash; acesso a alguma propriedade de uma express√£o. Um exemplo √© o acesso √† propriedade &lt;em&gt;length&lt;/em&gt; de uma lista, que retorna o n√∫mero de elementos nela&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; vogais = [&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;];
print(vogais.length); // 5
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;senten√ßas-de-controle-de-fluxo&#34;&gt;Senten√ßas de controle de fluxo&lt;/h2&gt;
&lt;h3 id=&#34;condicionais&#34;&gt;Condicionais&lt;/h3&gt;
&lt;p&gt;√â poss√≠vel testar as condi√ß√µes no seu programa para que ele rode peda√ßos de c√≥digo diferentes para cada uma delas. Pense na seguinte senten√ßa:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;Se&lt;/strong&gt; o usu√°rio estiver logado, (2) &lt;strong&gt;ent√£o&lt;/strong&gt; poder√° acessar a p√°gina inicial. (3) &lt;strong&gt;Caso contr√°rio&lt;/strong&gt;, (4) ser√° direcionado para a p√°gina de Login. Traduzindo para o c√≥digo:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if(usuarioEstiverLogado) { // 1
  redirecionarParaPaginaInicial(); // 2
} else { // 3
  redirecionarParaPaginaDeLogin(); // 4
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Perceba os n√∫meros na frase e no c√≥digo. Eles traduzem a forma na qual as condicionais funcionam:
1 - if &amp;ndash; se(condi√ß√£o a ser testada)
2 - c√≥digo a ser executado se a condi√ß√£o for verdadeira
3 - else &amp;ndash; caso contr√°rio
4 - c√≥digo executado caso a condi√ß√£o do n√∫mero 1 seja falsa.
Outro exemplo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Se o aluno tiver m√©dia &lt;strong&gt;maior ou igual&lt;/strong&gt; a 7 &lt;strong&gt;e&lt;/strong&gt; frequ√™ncia &lt;strong&gt;maior&lt;/strong&gt; que 75%, ser√° aprovado.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if(media &amp;gt;= 7 &amp;amp;&amp;amp; frequencia &amp;gt; 75) {
  print(&amp;#34;O aluno foi aprovado!&amp;#34;);
} else {
  print(&amp;#34;O aluno foi reprovado!&amp;#34;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As palavras em negrito correspondem aos operadores &amp;lsquo;&amp;gt;=&amp;rsquo;, &amp;amp;&amp;amp; e &amp;gt;. Agora, e se eu quiser testar a seguinte condi√ß√£o:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Se o aluno tiver m√©dia &lt;strong&gt;maior ou igual&lt;/strong&gt; a 7, ser√° aprovado. Caso a m√©dia seja maior ou igual a 5 e menor que 7, ficar√° em recupera√ß√£o. Caso contr√°rio, ser√° reprovado.
H√° duas condi√ß√µes a serem testadas: se ele ser√° aprovado, ou se ficar√° de recupera√ß√£o (apenas duas, pois qualquer nota menor que 5 far√° com que ele seja reprovado). Nesse tipo de situa√ß√£o, utilizamos as palavras reservadas &amp;ldquo;else if&amp;rdquo;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if(media &amp;gt;= 7) { // primeira condi√ß√£o
  print(&amp;#34;O aluno foi aprovado&amp;#34;);
} else if (media &amp;gt;= 5 &amp;amp;&amp;amp; media &amp;lt; 7) { // segunda condi√ß√£o
  print(&amp;#34;O aluno ficou em recupera√ß√£o&amp;#34;);
} else { // qualquer outra condi√ß√£o
  print(&amp;#34;O aluno foi reprovado&amp;#34;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;tern√°rio&#34;&gt;Tern√°rio&lt;/h3&gt;
&lt;p&gt;O operador tern√°rio funciona como o &amp;ldquo;if&amp;rdquo;, mas a sintaxe dele √© mais enxuta:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;media &amp;gt;= 7 ? print(&amp;#34;O aluno foi aprovado&amp;#34;) : print(&amp;#34;O aluno foi reprovado&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A sintaxe funciona da mesma forma:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;condi√ß√£o a ser testada ? c√≥digo caso seja verdadeira : c√≥digo caso seja falsa. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;√â poss√≠vel encadear v√°rias senten√ßas no tern√°rio. O mesmo exerc√≠cio do if-else ficaria assim:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;media &amp;gt;= 7 ? print(&amp;#34;O aluno foi aprovado&amp;#34;) : media &amp;gt;= 5 ? print(&amp;#34;O aluno ficou em recupera√ß√£o&amp;#34;) : print(&amp;#34;O aluno foi reprovado&amp;#34;); 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;switch---case&#34;&gt;Switch - case&lt;/h3&gt;
&lt;p&gt;Em vez de usar v√°rios &amp;ldquo;ifs&amp;rdquo; e &amp;ldquo;elses&amp;rdquo;, use switch-case (&lt;strong&gt;nem sempre √© recomendado por quest√£o de performance&lt;/strong&gt;). A sintaxe funciona assim:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch(variavel) {
    case(&amp;#39;caso1&amp;#39;):
        print(&amp;#39;caso1&amp;#39;);
        break;
    default:
        print(&amp;#39;qualquer mensagem padr√£o&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Os poss√≠veis valores da vari√°vel devem ser escritos dentro dos casos (case), e na linha seguinte, as instru√ß√µes para aquela determinada condi√ß√£o. Ao final h√° a palavra-chave &amp;ldquo;break&amp;rdquo;, que indica que o programa pode executar as senten√ßas seguintes ao switch. Se essa palavra for esquecida, ocorrer√° uma erro durante a execu√ß√£o.
Se mais de um caso for executar as mesmas sequ√™ncias, √© poss√≠vel utilizar &amp;ldquo;casos vazios&amp;rdquo;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch(variavel) {
    case(&amp;#39;caso1&amp;#39;):
    case(&amp;#39;caso2&amp;#39;):
    case(&amp;#39;caso3&amp;#39;):
        print(&amp;#39;Qualquer mensagem&amp;#39;);
        break;
    default:
        print(&amp;#39;qualquer mensagem padr√£o&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;la√ßos-de-repeti√ß√£o----while&#34;&gt;La√ßos de repeti√ß√£o &amp;ndash; While&lt;/h3&gt;
&lt;p&gt;Partes de um c√≥digo costumam ser repetidas durante a execu√ß√£o. Entretanto, n√£o √© necess√°rio escrev√™-las v√°rias vezes! Para isso, utiliza-se os la√ßos de repeti√ß√£o!
O &lt;strong&gt;while&lt;/strong&gt; √© um la√ßo que executa um determinado bloco de c√≥digo &lt;strong&gt;enquanto&lt;/strong&gt; uma condi√ß√£o for verdadeira. Com ele √© poss√≠vel realizar algoritmos simples, como contar n√∫meros, e at√© aplica√ß√µes mais pr√°ticas, como por exemplo o &lt;a href=&#34;https://developer.wordpress.org/themes/basics/the-loop/&#34;&gt;loop de postagens do WordPress&lt;/a&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int contador = 0;
while(contador &amp;lt; 10) {
  print(contador);
  contador++;
}

Resultado:
0
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Todo o c√≥digo localizado entre &amp;ldquo;{}&amp;rdquo; ser√° executado repetidas vezes at√© que a condi√ß√£o deixe de ser verdadeira. Preste muita aten√ß√£o na √∫ltima express√£o.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;contador++;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O contador aumentar√° em 1 toda vez que o c√≥digo se repetir at√© que a condi√ß√£o seja falsa. &lt;strong&gt;O que acontecer√° nos esquecermos de increment√°-lo?&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;la√ßos-de-repeti√ß√£o----do-while&#34;&gt;La√ßos de repeti√ß√£o &amp;ndash; Do While&lt;/h3&gt;
&lt;p&gt;Esse la√ßo √© parecido com o anterior. A diferen√ßa √© que o while checa a condi√ß√£o e depois executa o c√≥digo. J√° o do while executa o c√≥digo e depois checa. Veja a diferen√ßa em um algoritmo com a mesma l√≥gica:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int contador1 = 1;
while(contador1 &amp;lt; 1) {
  print(&amp;#34;contador1: $contador1&amp;#34;);
  contador1++;
}

Resultado: nada √© exibido no console.
  
int contador2 = 1;
do {
  print(&amp;#34;contador2: $contador2&amp;#34;);
  contador2++;
} while(contador2 &amp;lt; 1);

Resultado:
contador2: 1
&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;la√ßos-de-repeti√ß√£o----for&#34;&gt;La√ßos de repeti√ß√£o &amp;ndash; For&lt;/h3&gt;
&lt;p&gt;Esse la√ßo √© comumente utilizado em conjunto com listas, pois pode usar o n√∫mero de elementos delas como &amp;ldquo;contador&amp;rdquo; da repeti√ß√£o.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sintaxe tradicional:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;int&amp;gt; listaDeNumeros = [1, 2, 3, 4, 5];
for(int i = 0; i &amp;lt; listaDeNumeros.length; i++) {
  print(listaDeNumeros[i]);
}
//Resultado:
1
2
3
4
5
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;for&amp;hellip;in:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;int&amp;gt; listaDeNumeros = [1, 2, 3, 4, 5];
for(int i in listaDeNumeros) {
  print(i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;forEach() &amp;ndash; um m√©todo das listas que realiza uma a√ß√£o programada para cada elemento em uma determinada lista:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;int&amp;gt; listaDeNumeros = [1, 2, 3, 4, 5];
listaDeNumeros.forEach((numero) {
  print(numero);
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pense que &amp;ldquo;numero&amp;rdquo; √© como o nome de uma vari√°vel que, durante cada repeti√ß√£o ter√° um valor na lista seguindo uma ordem sequencial.&lt;/p&gt;
&lt;h2 id=&#34;fun√ß√µes&#34;&gt;Fun√ß√µes&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;tipo nomeDaFuncao(parametros) {
  declara√ß√µes a serem executadas
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A parte mais interessante desse texto. As fun√ß√µes s√£o blocos de c√≥digo que executam alguma opera√ß√£o. Quando utilizadas sozinhas, s√£o chamadas de &lt;strong&gt;fun√ß√µes&lt;/strong&gt;. Quando associadas a algum objeto, s√£o chamadas de &lt;strong&gt;m√©todos&lt;/strong&gt;. Algumas delas foram demonstradas ao longo dessa postagem. &amp;ldquo;stringQualquer.toUppercase()&amp;rdquo; √© uma delas.
A mais importante em programas Dart √© a fun√ß√£o main(), pois √© a respons√°vel por executar todo o c√≥digo. Sempre que abrir o DartPad, o editor vir√° com ela preenchida.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void main() {
  // digite o c√≥digo aqui
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A palavra &amp;ldquo;void&amp;rdquo; significa que a fun√ß√£o n√£o possui um valor de retorno. As fun√ß√µes podem retornar algum valor, que √© geralmente o resultado das instru√ß√µes executadas dentro delas. No caso de uma fun√ß√£o de soma, √© comum que ela retorne o resultado da soma dos n√∫meros passados como argumento.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int soma(int umNumero, int outroNumero) {
  return umNumero + outroNumero; // o valor de retorno (return) ser√° o resultado da express√£o.
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Perceba que declarei duas vari√°veis dentro dos par√™nteses: int umNumero e int outroNumero, mas n√£o atribui um valor a elas. Essas vari√°veis, chamadas de &lt;strong&gt;argumentos&lt;/strong&gt;, ter√£o seus valores atribu√≠dos durante a chamada da fun√ß√£o e separados por uma v√≠rgula:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(soma(1, 2)); // 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;√â poss√≠vel utilizar o valor de retorno de uma fun√ß√£o como argumento de outra fun√ß√£o. Essa √© uma abordagem de um outro &lt;strong&gt;paradigma de programa√ß√£o&lt;/strong&gt;, que trataremos em uma postagem pr√≥xima.&lt;/p&gt;
&lt;h2 id=&#34;fontes&#34;&gt;Fontes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dart.dev/guides/language/language-tour&#34;&gt;Language tour | Dart&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dart.dev/guides/language/effective-dart/design#prefer-annotating-with-dynamic-instead-of-letting-inference-fail&#34;&gt;Effective Dart: Design&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dart.dev/platforms&#34;&gt;Platforms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/50012596/how-does-dart-aot-work&#34;&gt;How Does Dart AOT Work?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hackernoon.com/why-flutter-uses-dart-dd635a054ebf&#34;&gt;Why Flutter Uses Dart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>
