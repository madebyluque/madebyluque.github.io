<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dotnet on Words of Luke Silva</title>
    <link>//localhost:1313/tags/dotnet/</link>
    <description>Recent content in Dotnet on Words of Luke Silva</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Mon, 18 Jul 2022 11:49:46 -0300</lastBuildDate><atom:link href="//localhost:1313/tags/dotnet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Automatizando a cria√ß√£o de requisi√ß√µes no JMeter utilizando Postman</title>
      <link>//localhost:1313/posts/jmeter/</link>
      <pubDate>Mon, 18 Jul 2022 11:49:46 -0300</pubDate>
      
      <guid>//localhost:1313/posts/jmeter/</guid>
      <description>&lt;p&gt;Faz um tempo que n√£o escrevo por aqui, mas hoje, enquanto estudava para resolver um problema do trampo, me deparei com uma t√©cnica que facilitou muito a forma de criar requisi√ß√µes no JMeter, ent√£o decidi compartilh√°-la.&lt;/p&gt;
&lt;p&gt;Antes de mais nada, quero agradecer aos meus amigos &lt;a href=&#34;https://twitter.com/ojuninrocha&#34;&gt;Jurno&lt;/a&gt; e &lt;a href=&#34;https://github.com/poferrari&#34;&gt;Jo√£o&lt;/a&gt;, que me guiaram na busca pela solu√ß√£o.&lt;/p&gt;
&lt;p&gt;Sem mais delongas, bora pro problema.&lt;/p&gt;
&lt;h2 id=&#34;o-problema&#34;&gt;O problema&lt;/h2&gt;
&lt;p&gt;Imagine que em um determinado momento, voc√™ e seu time precisar√£o realizar um teste de carga na aplica√ß√£o que voc√™s desenvolvem. Entretanto, voc√™s possuem pouco ou nenhum conhecimento com a ferramenta JMeter, uma das mais utilizadas para esse tipo de tarefa.
Uma das poss√≠veis solu√ß√µes √© gastar um bom tempo lendo a documenta√ß√£o para aprender a criar as requisi√ß√µes uma a uma. Inclusive, essa teria sido a minha decis√£o, n√£o fosse pelos conselhos dos amigos citados acima.&lt;/p&gt;</description>
      <content>&lt;p&gt;Faz um tempo que n√£o escrevo por aqui, mas hoje, enquanto estudava para resolver um problema do trampo, me deparei com uma t√©cnica que facilitou muito a forma de criar requisi√ß√µes no JMeter, ent√£o decidi compartilh√°-la.&lt;/p&gt;
&lt;p&gt;Antes de mais nada, quero agradecer aos meus amigos &lt;a href=&#34;https://twitter.com/ojuninrocha&#34;&gt;Jurno&lt;/a&gt; e &lt;a href=&#34;https://github.com/poferrari&#34;&gt;Jo√£o&lt;/a&gt;, que me guiaram na busca pela solu√ß√£o.&lt;/p&gt;
&lt;p&gt;Sem mais delongas, bora pro problema.&lt;/p&gt;
&lt;h2 id=&#34;o-problema&#34;&gt;O problema&lt;/h2&gt;
&lt;p&gt;Imagine que em um determinado momento, voc√™ e seu time precisar√£o realizar um teste de carga na aplica√ß√£o que voc√™s desenvolvem. Entretanto, voc√™s possuem pouco ou nenhum conhecimento com a ferramenta JMeter, uma das mais utilizadas para esse tipo de tarefa.
Uma das poss√≠veis solu√ß√µes √© gastar um bom tempo lendo a documenta√ß√£o para aprender a criar as requisi√ß√µes uma a uma. Inclusive, essa teria sido a minha decis√£o, n√£o fosse pelos conselhos dos amigos citados acima.&lt;/p&gt;
&lt;h2 id=&#34;a-solu√ß√£o&#34;&gt;A solu√ß√£o&lt;/h2&gt;
&lt;p&gt;√â poss√≠vel adicionar um elemento ao plano de teste do JMeter chamado &lt;a href=&#34;https://jmeter.apache.org/usermanual/jmeter_proxy_step_by_step.html&#34;&gt;&lt;strong&gt;HTTP(S) Test Script Recorder&lt;/strong&gt;&lt;/a&gt;. Ele √© respons√°vel por gravar requisi√ß√µes http e transform√°-las em uma HTTP Request (sampler).
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6gkliswkgkqjfr4upy0i.png&#34; alt=&#34;Imagem da UI do JMeter mostrando o HTTPS Test Script Recorder&#34;&gt;
Com esse elemento adicionado, basta ajustar as configura√ß√µes de proxy do Postman (ou qualquer outro sistema que voc√™ utiliza) para o endere√ßo do Test Script Recorder (localhost:8888 por default), rodar o elemento e ent√£o realizar uma requisi√ß√£o no sistema a ser testado.
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/rcnltqf07ag0br92nhlv.png&#34; alt=&#34;Configura√ß√µes de proxy do postman&#34;&gt;
Fiz uma requisi√ß√£o de exemplo na &lt;a href=&#34;https://pokeapi.co/api/v2/pokemon/ditto&#34;&gt;Pok√©API&lt;/a&gt;, e eis a requisi√ß√£o montada automaticamente no JMeter:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/29p2sjk2d7iewegegped.png&#34; alt=&#34;Interface do JMeter mostrando a requisi√ß√£o montada automaticamente&#34;&gt;&lt;/p&gt;
&lt;p&gt;√â poss√≠vel que seja necess√°rio realizar algumas altera√ß√µes na requisi√ß√£o gerada, mas creio que o procedimento descrito acima seja um excelente ponto de entrada para requisi√ß√µes mais elaboradas.&lt;/p&gt;
&lt;p&gt;Bem, caso haja alguma d√∫vida sobre o texto ou alguma sugest√£o de melhoria, pe√ßo que envie um coment√°rio üòé.
At√© a pr√≥xima!&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>.Net - Scoped, transient e singleton</title>
      <link>//localhost:1313/posts/lifecycles/</link>
      <pubDate>Tue, 19 Apr 2022 11:47:35 -0300</pubDate>
      
      <guid>//localhost:1313/posts/lifecycles/</guid>
      <description>&lt;p&gt;Vejo bastante gente com dificuldade em entender a diferen√ßa entre os principais tipos de lifecycle quando falamos sobre inje√ß√£o de depend√™ncia em .net. Criei um exemplo no &lt;a href=&#34;https://github.com/lukelima/LifecycleExample.&#34;&gt;GitHub&lt;/a&gt; e vou falar sobre ele.&lt;/p&gt;
&lt;p&gt;Basicamente criei 3 servi√ßos bastante simples e parecidos (apenas para fins did√°ticos) e os injetei utilizando AddSingleton, AddScoped e AddTransient.
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8noxoqf10ivwjukmajcf.png&#34; alt=&#34;Inje√ß√£o dos servi√ßos no arquivo Program.cs&#34;&gt;&lt;/p&gt;
&lt;p&gt;Esses servi√ßos s√≥ possuem uma propriedade, o Id, que √© criada no momento da instancia√ß√£o.
Criei um controller e injetei os servi√ßos por construtor.&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gtxlecy6yja6fdi733us.png&#34; alt=&#34;Inje√ß√£o dos servi√ßos no construtor&#34;&gt;&lt;/p&gt;</description>
      <content>&lt;p&gt;Vejo bastante gente com dificuldade em entender a diferen√ßa entre os principais tipos de lifecycle quando falamos sobre inje√ß√£o de depend√™ncia em .net. Criei um exemplo no &lt;a href=&#34;https://github.com/lukelima/LifecycleExample.&#34;&gt;GitHub&lt;/a&gt; e vou falar sobre ele.&lt;/p&gt;
&lt;p&gt;Basicamente criei 3 servi√ßos bastante simples e parecidos (apenas para fins did√°ticos) e os injetei utilizando AddSingleton, AddScoped e AddTransient.
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8noxoqf10ivwjukmajcf.png&#34; alt=&#34;Inje√ß√£o dos servi√ßos no arquivo Program.cs&#34;&gt;&lt;/p&gt;
&lt;p&gt;Esses servi√ßos s√≥ possuem uma propriedade, o Id, que √© criada no momento da instancia√ß√£o.
Criei um controller e injetei os servi√ßos por construtor.&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gtxlecy6yja6fdi733us.png&#34; alt=&#34;Inje√ß√£o dos servi√ßos no construtor&#34;&gt;&lt;/p&gt;
&lt;p&gt;Tamb√©m injetei uma inst√¢ncia do servi√ßo em cada m√©todo.
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/sbzeyh86fimx3xji9aeu.png&#34; alt=&#34;Inje√ß√£o dos servi√ßos em cada m√©todo&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;singleton&#34;&gt;Singleton&lt;/h2&gt;
&lt;p&gt;O servi√ßo √© criado &lt;strong&gt;uma √∫nica vez&lt;/strong&gt; e a mesma inst√¢ncia √© passada para todas as chamadas dele. Veja que o id, criado no momento da instancia√ß√£o, foi o mesmo (e continua sendo o mesmo independente da requisi√ß√£o):
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/djf0pqcgxgmr0k59iem2.png&#34; alt=&#34;Imagem mostra que uma √∫nica inst√¢ncia foi criada&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;scoped&#34;&gt;Scoped&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Uma √∫nica inst√¢ncia √© criada por requisi√ß√£o&lt;/strong&gt;. Ent√£o se o servi√ßo for chamado em v√°rios lugares em uma √∫nica requisi√ß√£o, a mesma inst√¢ncia ser√° passada. Outras inst√¢ncias ser√£o criadas para as pr√≥ximas requisi√ß√µes.&lt;/p&gt;
&lt;p&gt;Mesma requisi√ß√£o:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wxkot9z4wtnarvh9hvxt.png&#34; alt=&#34;Imagem mostra que uma √∫nica inst√¢ncia foi criada&#34;&gt;&lt;/p&gt;
&lt;p&gt;Requisi√ß√£o diferente:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/tg603oilzwhz3luzoo6h.png&#34; alt=&#34;Imagem mostra que uma nova inst√¢ncia foi criada para uma segunda requisi√ß√£o&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;transient&#34;&gt;Transient&lt;/h2&gt;
&lt;p&gt;Ele √© o mais custoso, pois se o servi√ßo for chamado em diversas classes, &lt;strong&gt;cada uma delas ter√° uma inst√¢ncia diferente&lt;/strong&gt;:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6ynbb4lr6b78cbg1zx5t.png&#34; alt=&#34;Imagem mostra que uma inst√¢ncia foi criada para cada chamada do servi√ßo&#34;&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Testes de unidade com NUnit para aplica√ß√µes C#</title>
      <link>//localhost:1313/posts/dotnet-unit-tests/</link>
      <pubDate>Fri, 18 Mar 2022 11:45:29 -0300</pubDate>
      
      <guid>//localhost:1313/posts/dotnet-unit-tests/</guid>
      <description>&lt;p&gt;Basicamente, testes automatizados s√£o uma forma de automatizar o processo de revis√£o e valida√ß√£o de um software atrav√©s de uma ferramenta program√°vel. Esse processo, que antes podia ser extremamente trabalhoso e demorado, pode ser feito em minutos &amp;ndash; ou at√© mesmo segundos, dependendo dos tipos e da quantidade de testes existentes na sua aplica√ß√£o.&lt;/p&gt;
&lt;p&gt;Mike Cohn criou o conceito de pir√¢mide de testes no livro &amp;ldquo;Succeeding with Agile&amp;rdquo;. √â basicamente uma forma de te fazer pensar nas v√°rias camadas de testes e em como elas devem estar presentes:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/u3ey9qc5peuj6d1jwuby.png&#34; alt=&#34;Pir√¢mide de testes cunhada po Cohn. A base dela √© composta por testes de unidade, seguida por testes de servi√ßos e por fim testes de ui. Quanto mais baixo o n√≠vel do teste na pir√¢mide, mais desacoplado e mais r√°pido ele √©&#34;&gt;
Quanto mais baixo o n√≠vel do teste na pir√¢mide, mais desacoplado e mais r√°pido ele √©, al√©m de mais numeroso.&lt;/p&gt;</description>
      <content>&lt;p&gt;Basicamente, testes automatizados s√£o uma forma de automatizar o processo de revis√£o e valida√ß√£o de um software atrav√©s de uma ferramenta program√°vel. Esse processo, que antes podia ser extremamente trabalhoso e demorado, pode ser feito em minutos &amp;ndash; ou at√© mesmo segundos, dependendo dos tipos e da quantidade de testes existentes na sua aplica√ß√£o.&lt;/p&gt;
&lt;p&gt;Mike Cohn criou o conceito de pir√¢mide de testes no livro &amp;ldquo;Succeeding with Agile&amp;rdquo;. √â basicamente uma forma de te fazer pensar nas v√°rias camadas de testes e em como elas devem estar presentes:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/u3ey9qc5peuj6d1jwuby.png&#34; alt=&#34;Pir√¢mide de testes cunhada po Cohn. A base dela √© composta por testes de unidade, seguida por testes de servi√ßos e por fim testes de ui. Quanto mais baixo o n√≠vel do teste na pir√¢mide, mais desacoplado e mais r√°pido ele √©&#34;&gt;
Quanto mais baixo o n√≠vel do teste na pir√¢mide, mais desacoplado e mais r√°pido ele √©, al√©m de mais numeroso.&lt;/p&gt;
&lt;p&gt;H√° in√∫meros tipos de teste &amp;ndash; muitos dos quais eu mesmo desconhe√ßo a fundo &amp;ndash; mas abordarei apenas os testes de unidade. Eles possuem esse nome pois tendem as menores unidades de classes e m√©todos de forma isolada do resto da aplica√ß√£o: sem acoplamento, nem nada. Apenas verifica√ß√µes para garantir que eles funcionem conforme o esperado, que as vari√°veis tenham os valores esperados etc.&lt;/p&gt;
&lt;p&gt;Uma disciplina importante para criar testes √© aquela chamada de TDD - Desenvolvimento orientado a testes. Nela, primeiro se escreve os testes, depois o c√≥digo para que o teste funcione, depois o c√≥digo √© refatorado para que se torne a melhor vers√£o que puder ser (esse √∫ltimo passo costuma ser bastante ignorado, gerando d√©bitos t√©cnicos).&lt;/p&gt;
&lt;p&gt;Ok, mas por que come√ßar pelos testes e n√£o pelo c√≥digo ? Porque para criar uma solu√ß√£o, √© necess√°rio saber o que precisa ser criado. √â necess√°rio saber de antem√£o o que uma classe deve fazer, o que um m√©todo deve fazer, o valor que uma vari√°vel deve ter etc. Sem isso em mente, √© muito f√°cil assumir que um resultado qualquer √© o correto. E √© assim que nascem os bugs üêû!&lt;/p&gt;
&lt;p&gt;Sem mais delongas, bora pro c√≥digo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/KGdKKipVBu9vO5hKkb/giphy.gif&#34; alt=&#34;Killjoy do jogo Valorant, em frente a um computador, arrumando os √≥culos no pr√≥prio rosto&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;m√£os-√†-obra&#34;&gt;M√£os √† obra&lt;/h2&gt;
&lt;p&gt;Criei uma aplica√ß√£o console para exemplificar. Nela, criarei uma classe &amp;ldquo;Conta&amp;rdquo; com as seguintes especifica√ß√µes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uma pessoa pode depositar qualquer valor maior que zero na conta;&lt;/li&gt;
&lt;li&gt;Uma pessoa pode sacar valores maiores que 0 e menores ou iguais ao saldo total;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Adicionei um projeto NUnit com o Visual Studio. Nele, criei uma classe chamada &lt;strong&gt;ContaTests&lt;/strong&gt;, conforme abaixo. O atributo &lt;strong&gt;[TestFixture]&lt;/strong&gt; indica que uma classe possui testes.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[TestFixture]
public class ContaTests
{
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;E ent√£o parti para o teste do primeiro m√©todo. Para que um m√©todo seja detectado como teste, √© necess√°rio adicionar o atributo &lt;strong&gt;[Test]&lt;/strong&gt; acima dele. Quanto ao nome do m√©todo de teste, fiz baseando-me em algumas recomenda√ß√µes que podem ser encontradas &lt;a href=&#34;https://docs.microsoft.com/pt-br/dotnet/core/testing/unit-testing-best-practices&#34;&gt;neste link.&lt;/a&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Test]
public void Depositar_RetornaSaldoMaisValorDepositado()
{
    // Arrange 
    
    // Act
    
    // Assert
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gosto de deixar os 3 coment√°rios em todos os testes que crio para separar bem as fases dele. Essas fases formam o padr√£o AAA, muito utilizado na ind√∫stria, e correspondem a:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arrange: fase na qual √© necess√°rio preparar teste preparando as vari√°veis, criando inst√¢ncias de objeto necess√°rias etc.;&lt;/li&gt;
&lt;li&gt;Act: fase na qual o m√©todo a ser testado √© executado;&lt;/li&gt;
&lt;li&gt;Assert: fase na qual √© feita a verifica√ß√£o de que o resultado obtido est√° de acordo com o esperado.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Na primeira fase, criei apenas uma inst√¢ncia da classe &lt;strong&gt;Conta&lt;/strong&gt;, que ainda n√£o existe, e ent√£o criei uma vari√°vel com o valor que espero obter como resultado do teste.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Arrange 
Conta conta = new Conta(&amp;#34;Lucas&amp;#34;, 100);
decimal saldoEsperado = 200;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Na fase de a√ß√£o, executei o m√©todo e armazenei o resultado em uma vari√°vel:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Act
var resultado = conta.Depositar(100);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;E por fim, fiz a verifica√ß√£o de que o resultado era igual ao saldoEsperado. Para isso, usei a classe Assert do NUnit. Ela cont√©m v√°rios m√©todos est√°ticos para testar in√∫meras situa√ß√µes, como listas, igualdades, nulos etc.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Assert
Assert.AreEqual(saldoEsperado, resultado);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O teste final ficou da seguinte forma:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Test]
public void Depositar_RetornaSaldoMaisValorDepositado()
{
    // Arrange 
    Conta conta = new Conta(&amp;#34;Lucas&amp;#34;, 100);
    decimal saldoEsperado = 200;

    Act
    var resultado = conta.Depositar(100);

    Assert
    Assert.AreEqual(saldoEsperado, resultado);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O teste n√£o compilar√° no primeiro momento pois a classe &lt;strong&gt;Conta&lt;/strong&gt; ainda n√£o existe. Logo, decidi cri√°-la:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Conta
{
    public Conta(string cliente, decimal saldo)
    {
        Cliente = cliente;
        Saldo = saldo;
    }

    public string Cliente { get; private set; }
    public decimal Saldo { get; private set; }

    public decimal Depositar(decimal valor)
    {
        Saldo += valor;
        return Saldo;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Aproveitei e tamb√©m criei o m√©todo &lt;strong&gt;Depositar&lt;/strong&gt;. Ele √© simples: recebe um valor e ent√£o adiciona esse valor √† propriedade &lt;strong&gt;Saldo&lt;/strong&gt; da classe.&lt;/p&gt;
&lt;p&gt;Adicionei uma refer√™ncia da classe no projeto de teste e ent√£o o executei. E ent√£o o teste passou !
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/h8esevtr3rklh3c27nqa.png&#34; alt=&#34;A imagem mostra que o teste foi aprovado ap√≥s a execu√ß√£o com os valores corretos&#34;&gt;&lt;/p&gt;
&lt;p&gt;‚ö†Ô∏è‚ö†Ô∏è Uma forma de garantir que o teste funciona √© fazendo-o quebrar propositalmente. Uma forma de quebrar o teste acima seria alterando o valor esperado para 300. Se o teste e o c√≥digo estiverem certos, o teste n√£o passar√°. Isso √© importante para evitar que o resultado seja um falso-positivo.‚ö†Ô∏è‚ö†Ô∏è&lt;/p&gt;
&lt;p&gt;Ok, o valor adicionado est√° correto, a soma est√° correta. Mas n√£o √© tudo a ser testado nesse m√©todo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uma pessoa pode depositar qualquer valor &lt;strong&gt;maior que zero&lt;/strong&gt; na conta;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Logo, √© necess√°rio criar um teste para verificar se o meu programa barra o dep√≥sito de um valor negativo como -R$100.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Test]
public void Deposito_QuandoExecutadoComValorNegativo_LancaLancaInvalidOperationException()
{
    //Arrange
    Conta conta = new Conta(&amp;#34;Lucas&amp;#34;, 100);

    //Act
    Func&amp;lt;decimal&amp;gt; acao = () =&amp;gt; conta.Depositar(-100);

    //Assert
    Assert.Throws&amp;lt;InvalidOperationException&amp;gt;(() =&amp;gt; acao());
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A grande diferen√ßa est√° nas fases &lt;strong&gt;Act&lt;/strong&gt; e &lt;strong&gt;Assert&lt;/strong&gt;. Assim que o valor -100 for detectado pelo m√©todo, √© necess√°rio que ele lance uma nova exce√ß√£o: &lt;strong&gt;InvalidOperationException&lt;/strong&gt;. Quando ela for lan√ßada, o programa sair√° daquele m√©todo antes de complet√°-lo, fazerndo com que o assert seja um pouco diferente. Para testar se ela realmente foi lan√ßada, primeiro armazenei o m√©todo em um delegate (eu poderia explicar o significado mas tanto a &lt;a href=&#34;https://docs.microsoft.com/pt-br/dotnet/api/system.delegate?view=net-6.0&#34;&gt;Microsoft&lt;/a&gt; quanto o &lt;a href=&#34;http://www.macoratti.net/17/01/net_deleg1.htm&#34;&gt;Macoratti&lt;/a&gt; fizeram um excelente trabalho falando sobre) e ent√£o utilizei o m√©todo Throws da classe Assert. Ele recebe o tipo da exce√ß√£o como generic (&lt;a href=&#34;https://docs.microsoft.com/pt-br/dotnet/standard/generics/&#34;&gt;artigo da Microsoft&lt;/a&gt; e &lt;a href=&#34;http://www.macoratti.net/11/07/net_gen1.htm&#34;&gt;artigo do Macoratti&lt;/a&gt;) e ent√£o consegue verificar se a exce√ß√£o foi lan√ßada.&lt;/p&gt;
&lt;p&gt;Ao rodar o teste na primeira vez, ele n√£o passoupois o m√©todo ainda n√£o lan√ßa a exce√ß√£o. Adicionei apenas 1 if para lan√ßar a exce√ß√£o e ent√£o o teste passou !&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public decimal Depositar(decimal valor)
{
    if (valor &amp;lt;= 0)
    {
        throw new InvalidOperationException(&amp;#34;N√£o √© poss√≠vel depositar valores negativos&amp;#34;);
    }
    Saldo += valor;
    return Saldo
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;‚ö†Ô∏è‚ö†Ô∏èPara quebrar o teste e verificar se ele n√£o d√° um falso positivo, √© poss√≠vel simplesmente alterar o tipo da exce√ß√£o esperada no Assert.‚ö†Ô∏è‚ö†Ô∏è&lt;/p&gt;
&lt;p&gt;Por se tratar de um exemplo, o m√©todo de saque ter√° testes bastante parecidos com o do dep√≥sito, ent√£o √© poss√≠vel verific√°-lo, assim como todo o resto do c√≥digo, nesse reposit√≥rio do GitHub que criei!&lt;/p&gt;
&lt;p&gt;Bem, essa foi uma breve introdu√ß√£o sobre testes de unidade. Na pr√≥xima parte falarei sobre &lt;strong&gt;Mocks&lt;/strong&gt; em um exemplo de uma API Rest e sobre o m√©todo &lt;strong&gt;SetUp&lt;/strong&gt;.Se curtiu, n√£o esque√ßa de compartilhar a postagem!&lt;/p&gt;
&lt;p&gt;At√© a pr√≥xima !&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/2YgCmRh9Arduw8LshF/giphy.gif&#34; alt=&#34;Snoopy Dogg acenando em despedida&#34;&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Como usar Redis em uma solu√ß√£o .Net</title>
      <link>//localhost:1313/posts/dotnet-redis/</link>
      <pubDate>Mon, 29 Nov 2021 11:41:55 -0300</pubDate>
      
      <guid>//localhost:1313/posts/dotnet-redis/</guid>
      <description>&lt;p&gt;Ol√°!&lt;/p&gt;
&lt;p&gt;Faz algum tempo que n√£o escrevo por aqui mas senti saudades disso. Desde que escrevi meu √∫ltimo artigo grande (&lt;a href=&#34;https://dev.to/cephalopodluke/introducao-a-programacao-com-dart-aji&#34;&gt;uma introdu√ß√£o sobre flutter&lt;/a&gt;), comecei a trabalhar com .Net e C#. √â poss√≠vel ver algumas semelhan√ßas em ambas linguagens e isso facilitou bastante meu aprendizado nela.&lt;/p&gt;
&lt;p&gt;Bem, tenho desenvolvido algumas APIs e trabalhado com alguns problemas envolvendo implanta√ß√µes de aplica√ß√µes, bem coisa de backend mesmo. Um dos primeiros problemas que precisei resolver foi implementar uma forma de uso de cache utilizando Redis em uma API.&lt;/p&gt;</description>
      <content>&lt;p&gt;Ol√°!&lt;/p&gt;
&lt;p&gt;Faz algum tempo que n√£o escrevo por aqui mas senti saudades disso. Desde que escrevi meu √∫ltimo artigo grande (&lt;a href=&#34;https://dev.to/cephalopodluke/introducao-a-programacao-com-dart-aji&#34;&gt;uma introdu√ß√£o sobre flutter&lt;/a&gt;), comecei a trabalhar com .Net e C#. √â poss√≠vel ver algumas semelhan√ßas em ambas linguagens e isso facilitou bastante meu aprendizado nela.&lt;/p&gt;
&lt;p&gt;Bem, tenho desenvolvido algumas APIs e trabalhado com alguns problemas envolvendo implanta√ß√µes de aplica√ß√µes, bem coisa de backend mesmo. Um dos primeiros problemas que precisei resolver foi implementar uma forma de uso de cache utilizando Redis em uma API.&lt;/p&gt;
&lt;p&gt;Apenas para esclarecimento, cache √© um local de armazenamento de dados tempor√°rios que servir√£o para ajudar aplica√ß√µes web, mobile etc. Implementar cache na sua solu√ß√£o pode trazer diversos benef√≠cios como economizar banda, reduzir tempo de resposta, realizar menos chamadas ao banco em alguns casos espec√≠ficos etc. Entretanto tamb√©m pode causar in√∫meros problemas. Um deles √© o de os dados n√£o estarem mais atualizados em solu√ß√µes que esses dados mudam frequentemente.&lt;/p&gt;
&lt;p&gt;Criei um c√≥digo para esse artigo que pode ser encontrado &lt;a href=&#34;https://github.com/lukelima/ExemploRedis&#34;&gt;nesse reposit√≥rio do GitHub&lt;/a&gt;. Nele, criei consumi a &lt;a href=&#34;https://pokeapi.co/&#34;&gt;Pok√©Api&lt;/a&gt;, uma API com dados de quase todos os pok√©mons lan√ßados at√© hoje. Segui a pol√≠tica de fair use dela que diz &lt;em&gt;&amp;ldquo;Locally cache resources whenever you request them.&amp;rdquo;&lt;/em&gt; (armazene recursos em cache quando os consultar) e salvei todas as requisi√ß√µes em cache por um tempo limitado.&lt;/p&gt;
&lt;p&gt;A estrutura de pastas do projeto ficou da seguinte forma:za&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExemploRedis/
‚îú‚îÄ Controllers/
‚îÇ  ‚îú‚îÄ PokemonController.cs
‚îú‚îÄ Extensions/
‚îÇ  ‚îú‚îÄ DistributedCacheExtension.cs
‚îú‚îÄ Services/
‚îÇ  ‚îú‚îÄ Interfaces/
‚îÇ  ‚îÇ  ‚îú‚îÄ ICacheService.cs
‚îÇ  ‚îÇ  ‚îú‚îÄ IPokemonService.cs
‚îÇ  ‚îú‚îÄ PokemonCacheService.cs
‚îÇ  ‚îú‚îÄ PokemonService.cs
‚îú‚îÄ Pokemon.cs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O arquivo &lt;strong&gt;Pokemon.cs&lt;/strong&gt; cont√©m as informa√ß√µes de Pok√©mons da API. Para a simplicidade do exemplo, adicionei apenas 3 propriedades:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Pokemon
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Weight { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Adicionei o pacote &lt;strong&gt;Microsoft.Extensions.Caching.Redis&lt;/strong&gt; NuGet para trabalhar com o Redis. Com ele, criei a extens√£o &lt;strong&gt;Extensions/DistributedCacheExtension.cs&lt;/strong&gt; para adicionar o servi√ßo √† API:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public static IServiceCollection AddDistributedCache(
    this IServiceCollection services,
    IConfiguration configuration)
{
    services.AddDistributedRedisCache(options =&amp;gt;
    {
        options.Configuration = 
            configuration.GetConnectionString(&amp;#34;Redis&amp;#34;);
        options.InstanceName = 
            configuration[&amp;#34;Redis:InstanceName&amp;#34;];
    });
    return services;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As options da configura√ß√£o s√£o autoexplicativas: string de conex√£o ao servi√ßo e nome da inst√¢ncia.
Adicionei essa extens√£o no arquivo Startup.cs, no m√©todo &lt;strong&gt;ConfigureServices&lt;/strong&gt;, com a seguinte linha de c√≥digo:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;services.AddDistributedCache(Configuration);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Com o Redis configurado, desenvolvi um servi√ßo que me auxiliaria a buscar e adicionar dados a ele visando evitar repeti√ß√£o de c√≥digo.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public interface ICacheService&amp;lt;T&amp;gt;
{
    Task&amp;lt;T&amp;gt; Get(int id);
    Task Set(T content);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O c√≥digo acima √© da interface do servi√ßo. Decidi usar um tipo gen√©rico nela para que ela seja reaproveitada para qualquer objeto que eu precisar. O servi√ßo que a implementa ficou assim:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class PokemonCacheService : ICacheService&amp;lt;Pokemon&amp;gt;
{
    private readonly IDistributedCache _distributedCache;
    private readonly DistributedCacheEntryOptions _options;
    private const string Prefix = &amp;#34;pokemon_&amp;#34;;

    public PokemonCacheService(IDistributedCache distributedCache)
    {
        _distributedCache = distributedCache;
        _options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = 
                TimeSpan.FromSeconds(120),
            SlidingExpiration = TimeSpan.FromSeconds(60)
        };
    }

    public async Task&amp;lt;Pokemon&amp;gt; Get(int id)
    {
        var key = Prefix + id;
        var cache = await _distributedCache.GetStringAsync(key);
        if (cache is null)
        {
            return null;
        }
        var pokemon = JsonConvert.DeserializeObject&amp;lt;Pokemon&amp;gt; 
            (cache);
        return pokemon;
    }

    public async Task Set(Pokemon content)
    {
        var key = Prefix + content.Id;
        var pokemonString = JsonConvert.SerializeObject(content);
        await _distributedCache.SetStringAsync(key, pokemonString, 
            _options);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Passando por todos os pontos:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private readonly IDistributedCache _distributedCache;
private readonly DistributedCacheEntryOptions _options;
private const string Prefix = &amp;#34;pokemon_&amp;#34;;

public PokemonCacheService(IDistributedCache distributedCache)
{
    _distributedCache = distributedCache;
    _options = new DistributedCacheEntryOptions
    {
        AbsoluteExpirationRelativeToNow =   
            TimeSpan.FromSeconds(120),
        SlidingExpiration = TimeSpan.FromSeconds(60)
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Os dois primeiros campos, &lt;strong&gt;_distributedCache&lt;/strong&gt; e &lt;strong&gt;_options&lt;/strong&gt; est√£o relacionados diretamente √† configura√ß√£o do Redis. &lt;strong&gt;IDistributedCache&lt;/strong&gt; √© a interface que utilizei para acessar o Redis atrav√©s de inje√ß√£o de depend√™ncia. J√° &lt;strong&gt;DistributedCacheEntryOptions&lt;/strong&gt; √© a classe respons√°vel por configurar op√ß√µes como &lt;strong&gt;AbsoluteExpirationRelativeToNow&lt;/strong&gt; e &lt;strong&gt;SlidingExpiration&lt;/strong&gt;, que referem-se ao tempo total que um dado ficar√° armazenado e ao tempo que ele pode ficar armazenado sem ser consultado (nunca maior que o tempo absoluto), respectivamente. &lt;strong&gt;Prefix&lt;/strong&gt; refere-se ao prefixo que utilizo para armazenar os pokemons. Utilizo ele + o id do pokemon para armazenar os dados com chaves √∫nicas &amp;ndash; o que facilita a consulta posterior.&lt;/p&gt;
&lt;p&gt;Sobre o m√©todo Get:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public async Task&amp;lt;Pokemon&amp;gt; Get(int id)
{
    var key = Prefix + id;
    var cache = await _distributedCache.GetStringAsync(key);
    if (cache is null)
    {
        return null;
    }
    var pokemon = JsonConvert.DeserializeObject&amp;lt;Pokemon&amp;gt;(cache);
    return pokemon;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nele, crio a chave como prefixo + id do pokemon e busco o dado no cache utilizando o m√©todo &lt;strong&gt;GetStringAsync(key)&lt;/strong&gt; da interface IDistributedCache. Se ele for nulo, retorno nulo (ou poderia notificar um erro ou lan√ßar uma exce√ß√£o). Caso o contr√°rio, deserializo a string obtida em pokemon e retorno o valor.&lt;/p&gt;
&lt;p&gt;Sobre o m√©todo Set:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public async Task Set(Pokemon content)
{
    var key = Prefix + content.Id;
    var pokemonString = JsonConvert.SerializeObject(content);
    await _distributedCache.SetStringAsync(key, pokemonString, 
        _options);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nele, crio a chave da mesma forma, com o prefixo + o id do pokemon informado, ent√£o serializo o objeto em string e armazeno no Redis utilizando o m√©todo &lt;strong&gt;SetStringAsync()&lt;/strong&gt; da interface IDistributedCache. Esse m√©todo recebe a chave que ser√° utilizada para armazenamento (a mesma a ser consultada depois), o dado que ser√° armazenado e as op√ß√µes de armazenamento (lembra que configurei a expira√ß√£o dos dados no construtor ? Pois bem, √© aqui que informo essa configura√ß√£o).&lt;/p&gt;
&lt;p&gt;Com o servi√ßo de cache pronto, desenvolvi o servi√ßo de consulta √† Pok√©Api. Interface:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public interface IPokemonService
{
    Task&amp;lt;Pokemon&amp;gt; GetPokemon(int id);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;E o servi√ßo que a implementa:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class PokemonService : IPokemonService
{
    private readonly HttpClient _httpClient;

    public PokemonService(HttpClient httpClient)
    {
        _httpClient = httpClient;
        _httpClient.BaseAddress = new 
            Uri(&amp;#34;https://pokeapi.co/api/v2/&amp;#34;);
    }

    public async Task&amp;lt;Pokemon&amp;gt; GetPokemon(int id)
    {
        var response = await 
            _httpClient.GetAsync($&amp;#34;pokemon/{id}&amp;#34;);
        var content = await response.Content.ReadAsStringAsync();
        var pokemon = JsonConvert.DeserializeObject&amp;lt;Pokemon&amp;gt; 
            (content);
        return pokemon;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O servi√ßo √© bem simples: possui um campo HttpClient que foi injetado e o m√©todo GetPokemon(int id), que faz a chamada √† API e retorna um pok√©mon. Adicionei o HttpClient ao startup utilizando a seguinte linha de c√≥digo no arquivo &lt;strong&gt;Startup.cs&lt;/strong&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    services.AddHttpClient&amp;lt;IPokemonService, PokemonService&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;√â importante notar que esse m√©todo adiciona tanto o client como o servi√ßo a ser injetado por depend√™ncia.&lt;/p&gt;
&lt;p&gt;Com tudo pronto, criei um controller para servir esses dados:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[ApiController]
[Route(&amp;#34;api/[controller]&amp;#34;)]
public class PokemonController : ControllerBase
{
    private readonly IPokemonService _pokemonService;
    private readonly ICacheService&amp;lt;Pokemon&amp;gt; _pokemonCacheService;

    public PokemonController(IPokemonService pokemonService, 
        ICacheService&amp;lt;Pokemon&amp;gt; pokemonCacheService)
    {
        _pokemonService = pokemonService;
        _pokemonCacheService = pokemonCacheService;
    }

    [HttpGet(&amp;#34;{id}&amp;#34;)]
    public async Task&amp;lt;IActionResult&amp;gt; Get(int id)
    {
        Pokemon pokemon = await _pokemonCacheService.Get(id);
        if (pokemon is null)
        {
            pokemon = await _pokemonService.GetPokemon(id);
            await _pokemonCacheService.Set(pokemon);
        }
        return Ok(pokemon);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nele, injeto tanto o PokemonService quanto o CacheService pelo construtor. Como essa Api faz apenas a pesquisa de pokemons, o controller possui apenas 1 m√©todo: Get. Ele recebe um id na rota, ent√£o verifica se h√° no cache um pokemon com esse id. Se houver, ele retorna o pok√©mon. Caso n√£o haja, ele chama o service que consultar√° a API e ent√£o devolve o pok√©mon.&lt;/p&gt;
&lt;p&gt;E esse √© o fim do tutorial. Lembre-se de baixar o reposit√≥rio no &lt;a href=&#34;https://github.com/lukelima/ExemploRedis&#34;&gt;GitHub&lt;/a&gt; caso queira estud√°-lo melhor. Caso queira, deixei um arquivo docker-compose.yml para facilitar o uso do Redis.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
