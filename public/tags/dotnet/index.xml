<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dotnet on Thoughts of of Lucas Silva</title>
    <link>//localhost:1313/tags/dotnet/</link>
    <description>Recent content in Dotnet on Thoughts of of Lucas Silva</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Sun, 10 Mar 2024 11:56:22 -0300</lastBuildDate><atom:link href="//localhost:1313/tags/dotnet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>EF Core - Explos√£o Cartesiana</title>
      <link>//localhost:1313/posts/cartesian-explosion/</link>
      <pubDate>Sun, 10 Mar 2024 11:56:22 -0300</pubDate>
      
      <guid>//localhost:1313/posts/cartesian-explosion/</guid>
      <description>&lt;h2 id=&#34;introdu√ß√£o&#34;&gt;Introdu√ß√£o&lt;/h2&gt;
&lt;p&gt;Atuei em v√°rios projetos que utilizavam EF Core, e em uma determinada ocasi√£o, encontrei, junto ao meu time, um problema que n√£o fazia muito sentido: uma query simples, com poucos Includes, em tabelas que n√£o possu√≠am tanto registros (quando comparada a outras tabelas do mesmo banco), estourava timeout. Ap√≥s an√°lise, o time entendeu que o problema ocorria devido a um fen√¥meno chamado &lt;strong&gt;Explos√£o cartesiana&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-que-√©&#34;&gt;O que √©?&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;explos√£o cartesiana&lt;/strong&gt; ocorre quando, ao realizar queries com joins em propriedades de navega√ß√£o de entidades no mesmo n√≠vel hier√°rquico em bancos relacionais, o banco de dados retorna um produto vetorial (cross product). Ou seja, cada linha de uma propriedade de navega√ß√£o √© combinada com cada linha da outra propriedade.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;introdu√ß√£o&#34;&gt;Introdu√ß√£o&lt;/h2&gt;
&lt;p&gt;Atuei em v√°rios projetos que utilizavam EF Core, e em uma determinada ocasi√£o, encontrei, junto ao meu time, um problema que n√£o fazia muito sentido: uma query simples, com poucos Includes, em tabelas que n√£o possu√≠am tanto registros (quando comparada a outras tabelas do mesmo banco), estourava timeout. Ap√≥s an√°lise, o time entendeu que o problema ocorria devido a um fen√¥meno chamado &lt;strong&gt;Explos√£o cartesiana&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;o-que-√©&#34;&gt;O que √©?&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;explos√£o cartesiana&lt;/strong&gt; ocorre quando, ao realizar queries com joins em propriedades de navega√ß√£o de entidades no mesmo n√≠vel hier√°rquico em bancos relacionais, o banco de dados retorna um produto vetorial (cross product). Ou seja, cada linha de uma propriedade de navega√ß√£o √© combinada com cada linha da outra propriedade.&lt;/p&gt;
&lt;p&gt;Esse comportamento pode gerar um n√∫mero inesperado de combina√ß√µes entre os dados, aumentando drasticamente o volume de informa√ß√µes trafegadas entre o banco de dados e a aplica√ß√£o. &lt;strong&gt;Consequentemente, isso pode afetar o desempenho da aplica√ß√£o, aumentar os custos de infraestrutura e consumo de recursos, al√©m de tornar a depura√ß√£o e otimiza√ß√£o mais complexa.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;como-resolver&#34;&gt;Como resolver?&lt;/h2&gt;
&lt;p&gt;Uma das melhores formas de lidar com isso √© utilizando queries separadas para carregar os dados envolvidos. O EF Core oferece uma solu√ß√£o simples para isso atrav√©s do m√©todo &lt;code&gt;AsSplitQuery()&lt;/code&gt;, que carregar√° as cole√ß√µes utilizando m√∫ltiplas queries, em vez de uma √∫nica query.&lt;/p&gt;
&lt;p&gt;Os exemplos abaixo foram feitos com uma cole√ß√£o de 100000 blogs armazenados em uma inst√¢ncia de SQL Server 2022, rodando atrav√©s de um cont√™iner Docker.&lt;/p&gt;
&lt;h3 id=&#34;exemplo-sem-assplitquery&#34;&gt;Exemplo sem AsSplitQuery&lt;/h3&gt;
&lt;p&gt;C√≥digo:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var¬†withoutSplitQuery¬†=¬†context.Blogs
	.Include(b¬†=&amp;gt;¬†b.Posts)
	.Include(b¬†=&amp;gt;¬†b.BlogContributors)
		.ThenInclude(bc¬†=&amp;gt;¬†bc.Contributor)
	.ToList();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nesse exemplo, cada Blog possui uma cole√ß√£o de Posts e uma de BlogContributors. Como ambas est√£o no mesmo n√≠vel, cada post ser√° combinado com cada contribuinte, o que resulta em um n√∫mero de linhas maior do que o necess√°rio.&lt;/p&gt;
&lt;p&gt;Query gerada:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT [b].[BlogId], [b].[Name], [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title], [t].[BlogId], [t].[ContributorId], [t].[ContributorId0], [t].[Name]
      FROM [Blogs] AS [b]
      LEFT JOIN [Posts] AS [p] ON [b].[BlogId] = [p].[BlogId]
      LEFT JOIN (
          SELECT [b0].[BlogId], [b0].[ContributorId], [c].[ContributorId] AS [ContributorId0], [c].[Name]
          FROM [BlogContributors] AS [b0]
          INNER JOIN [Contributors] AS [c] ON [b0].[ContributorId] = [c].[ContributorId]
      ) AS [t] ON [b].[BlogId] = [t].[BlogId]
      ORDER BY [b].[BlogId], [p].[PostId], [t].[BlogId], [t].[ContributorId]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Resultado na busca de 100000 registros:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*************************************************************************
Tempo de execu√ß√£o sem splitquery: 4526ms
N√∫mero de blogs retornados: 100000
*************************************************************************
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;exemplo-com-assplitquery&#34;&gt;Exemplo com AsSplitQuery&lt;/h3&gt;
&lt;p&gt;C√≥digo:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var¬†withSplitQuery¬†=¬†context.Blogs
	.Include(b¬†=&amp;gt;¬†b.Posts)
	.Include(b¬†=&amp;gt;¬†b.BlogContributors)
		.ThenInclude(bc¬†=&amp;gt;¬†bc.Contributor)
	.AsSplitQuery()
	.ToList();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Queries geradas:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT [b].[BlogId], [b].[Name]
      FROM [Blogs] AS [b]
      ORDER BY [b].[BlogId]

SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title], [b].[BlogId]
      FROM [Blogs] AS [b]
      INNER JOIN [Posts] AS [p] ON [b].[BlogId] = [p].[BlogId]
      ORDER BY [b].[BlogId]

SELECT [t].[BlogId], [t].[ContributorId], [t].[ContributorId0], [t].[Name], [b].[BlogId]
      FROM [Blogs] AS [b]
      INNER JOIN (
          SELECT [b0].[BlogId], [b0].[ContributorId], [c].[ContributorId] AS [ContributorId0], [c].[Name]
          FROM [BlogContributors] AS [b0]
          INNER JOIN [Contributors] AS [c] ON [b0].[ContributorId] = [c].[ContributorId]
      ) AS [t] ON [b].[BlogId] = [t].[BlogId]
      ORDER BY [b].[BlogId]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Resultado na busca de 100000 registros:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;*************************************************************************
Tempo de execu√ß√£o com splitquery: 3664ms
N√∫mero de blogs retornados: 100000
*************************************************************************
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Por mais que os exemplos acima tenham utilizado um n√∫mero relativamente pequeno de dados, os resultados de 10 execu√ß√µes do teste com dados diferentes foram consistentes: as buscas com queries separadas foram mais r√°pidas que as buscas com queries √∫nicas. Inclusive, o pr√≥prio EF lan√ßa um erro ao executar uma query que possa causar uma explos√£o cartesiana:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Compiling a query which loads related collections for more than onecollection navigation, either via &amp;#39;Include&amp;#39; or through projection, but no &amp;#39;QuerySplittingBehavior&amp;#39; has been configured. By default, Entity Framework will use &amp;#39;QuerySplittingBehavior.SingleQuery&amp;#39;, which can potentially result in slow query performance.
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Importante!&lt;/strong&gt;
H√° in√∫meras vari√°veis que podem impactar na performance de uma query. Esse texto e os testes acima tratam exclusivamente sobre o problema de &lt;strong&gt;explos√£o cartesiana.&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;configura√ß√£o-via-dbcontext&#34;&gt;Configura√ß√£o via DbContext&lt;/h3&gt;
&lt;p&gt;O EF permite a configura√ß√£o do comportamento como padr√£o. Para isso, basta configurar o DbContext:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;optionsBuilder
    .UseSqlServer(&amp;#34;ConnectionString&amp;#34;, o =&amp;gt;
    .UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery));
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;fontes-e-recursos&#34;&gt;Fontes e recursos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.milanjovanovic.tech/blog/how-to-improve-performance-with-ef-core-query-splitting&#34;&gt;How To Improve Performance With EF Core Query Splitting&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/pt-br/ef/core/querying/single-split-queries&#34;&gt;Consultas √∫nicas vs. consultas divididas&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>TestContainers para testes de integra√ß√£o com .Net</title>
      <link>//localhost:1313/posts/testcontainers/</link>
      <pubDate>Tue, 06 Feb 2024 11:54:32 -0300</pubDate>
      
      <guid>//localhost:1313/posts/testcontainers/</guid>
      <description>&lt;h2 id=&#34;introdu√ß√£o&#34;&gt;Introdu√ß√£o&lt;/h2&gt;
&lt;p&gt;Diferente de testes de unidade, os testes de integra√ß√£o permitem validar o comportamento de uma aplica√ß√£o quando todos os componentes dela s√£o utilizados em conjunto. Isso inclui bancos de dados, servi√ßos de cache, servi√ßos de mensageria etc.&lt;/p&gt;
&lt;p&gt;Na teoria, tudo parece interessante e simples. Mas esses testes podem gerar e alterar um grande volume de dados, ent√£o √© necess√°rio tomar cuidado com os recursos utilizados. At√© porque acidentes acontecem, e talvez, em um descuido, voc√™ pode acabar executando um DELETE sem WHERE, levando √† exclus√£o total de uma tabela. üòÖ&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;introdu√ß√£o&#34;&gt;Introdu√ß√£o&lt;/h2&gt;
&lt;p&gt;Diferente de testes de unidade, os testes de integra√ß√£o permitem validar o comportamento de uma aplica√ß√£o quando todos os componentes dela s√£o utilizados em conjunto. Isso inclui bancos de dados, servi√ßos de cache, servi√ßos de mensageria etc.&lt;/p&gt;
&lt;p&gt;Na teoria, tudo parece interessante e simples. Mas esses testes podem gerar e alterar um grande volume de dados, ent√£o √© necess√°rio tomar cuidado com os recursos utilizados. At√© porque acidentes acontecem, e talvez, em um descuido, voc√™ pode acabar executando um DELETE sem WHERE, levando √† exclus√£o total de uma tabela. üòÖ&lt;/p&gt;
&lt;p&gt;Para evitar esse tipo de problemas, √© poss√≠vel criar esses recursos a partir de containers Docker por meio da lib &lt;a href=&#34;https://testcontainers.com/&#34;&gt;TestContainers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Neste tutorial, explicarei os passos para a utiliza√ß√£o desses containers em uma API .Net.&lt;/p&gt;
&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;
&lt;p&gt;O projeto completo pode ser encontrado &lt;a href=&#34;https://github.com/madebyluque/TutorialIntegrationTests&#34;&gt;neste link&lt;/a&gt;. Trata-se de uma API de gerenciamento de tarefas (a famosa &amp;ldquo;To-Do list&amp;rdquo;). Ela consiste de basicamente 3 partes:&lt;/p&gt;
&lt;p&gt;Uma entidade:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;namespace IntegrationTestingDemo.API;

public class Todo
{
    public Todo()
    {
    }

    public Todo(string title, string description)
    {
        Title = title;
        Description = description;
        Id = Guid.NewGuid().ToString().Replace(&amp;#34;-&amp;#34;, &amp;#34;&amp;#34;);
        CreatedAt = DateTime.UtcNow;
        Done = false;
    }

    public string Id { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public bool Done { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? CompletedAt { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Um service com a l√≥gica da aplica√ß√£o (visando a simplicidade, algumas opera√ß√µes n√£o foram criadas):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class TodoService(TodoContext context) : ITodoService
{
    private readonly TodoContext _context = context;

    public async Task&amp;lt;string&amp;gt; Create(string title, string description)
    {
        var todo = new Todo(title, description);
        await _context.AddAsync(todo);
        await _context.SaveChangesAsync();
        return todo.Id;
    }

    public async Task&amp;lt;List&amp;lt;Todo&amp;gt;&amp;gt; GetAll()
    {
        return await _context.Todos.OrderBy(x =&amp;gt; x.CreatedAt).ToListAsync();
    }

    public async Task&amp;lt;Todo&amp;gt; GetById(string id)
    {
        return await _context.Todos.FirstOrDefaultAsync(x =&amp;gt; x.Id == id);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;E um controller:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[ApiController]
[Route(&amp;#34;[controller]&amp;#34;)]
public class TodoController(ITodoService todoService) : ControllerBase
{
    private readonly ITodoService _todoService = todoService;

    [HttpPost]
    public async Task&amp;lt;IActionResult&amp;gt; Create([FromBody] CreateTodoModel model)
    {
        var result = await _todoService.Create(model.Title, model.Description);
        return CreatedAtRoute(nameof(GetById), routeValues: new { Id = result }, result);
    }

    [HttpGet]
    public async Task&amp;lt;IActionResult&amp;gt; GetAll()
    {
        var todos = await _todoService.GetAll();
        return Ok(todos);
    }

    [HttpGet(&amp;#34;{id}&amp;#34;, Name = &amp;#34;GetById&amp;#34;)]
    public async Task&amp;lt;IActionResult&amp;gt; GetById(string id)
    {
        var todo = await _todoService.GetById(id);
        return Ok(todo);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;testes&#34;&gt;Testes&lt;/h2&gt;
&lt;p&gt;A configura√ß√£o de &lt;strong&gt;TestContainer&lt;/strong&gt; √© feita na cria√ß√£o da &lt;strong&gt;WebApplicationFactory&lt;/strong&gt; para os testes de integra√ß√£o. Neste tutorial, decidi utilizar PostgreSQL. A cria√ß√£o de um container desse banco de dados pode ser feita da seguinte forma:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private readonly PostgreSqlContainer _postgres = new PostgreSqlBuilder().WithUsername(&amp;#34;postgres&amp;#34;).WithPassword(&amp;#34;postgres&amp;#34;).Build();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;√â poss√≠vel alterar o usu√°rio e a senha da forma que desejar. H√°, inclusive, a op√ß√£o de alterar outras configura√ß√µes no builder, como o nome do db, o host etc.&lt;/p&gt;
&lt;p&gt;Com o container criado, √© poss√≠vel obter a connection string dele da seguinte forma:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;_postgres.GetConnectionString()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pode ser necess√°rio remover o dbContext da aplica√ß√£o para adicionar um novo com a connection string do container de teste. Nesse caso, √© poss√≠vel faz√™-lo da seguinte forma:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var context = services.FirstOrDefault(descriptor =&amp;gt; descriptor.ServiceType == typeof(TodoContext));
if (context != null)
{
    services.Remove(context);
    var options = services.Where(r =&amp;gt; (r.ServiceType == typeof(DbContextOptions))
      || (r.ServiceType.IsGenericType &amp;amp;&amp;amp; r.ServiceType.GetGenericTypeDefinition() == typeof(DbContextOptions&amp;lt;&amp;gt;))).ToArray();
    foreach (var option in options)
    {
        services.Remove(option);
    }
}

services.AddDbContext&amp;lt;TodoContext&amp;gt;(options =&amp;gt;
{
    options.UseNpgsql(_postgres.GetConnectionString());
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Por fim, √© interessante que sua classe de &lt;strong&gt;WebApplicationFactory&lt;/strong&gt; implemente a interface IAsyncLifetime para que o container criado seja inicializado / parado.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public Task InitializeAsync()
{
    return _postgres.StartAsync();
}

public new Task DisposeAsync()
{
    return _postgres.StopAsync();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Com a configura√ß√£o feita, j√° √© poss√≠vel criar testes de integra√ß√£o. No teste abaixo, utilizei o TodoService para criar uma tarefa, e ent√£o verifiquei se os dados no banco de dados estavam de acordo com o que deveriam:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Fact]
public async Task Create_ShouldCreateTodoAndReturnItsId()
{
    // Act
    var result = await _todoService.Create(TestTitle, TestDescription);

    // Assert
    var todo = await _dbContext.Todos.FirstOrDefaultAsync(x =&amp;gt; x.Id == result);
    Assert.NotNull(todo);
    Assert.False(todo.Done);
    Assert.Equal(TestTitle, todo.Title);
    Assert.Equal(TestDescription, todo.Description);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(Acesse o &lt;a href=&#34;https://github.com/madebyluque/TutorialIntegrationTests&#34;&gt;reposit√≥rio&lt;/a&gt; para verificar os demais testes.)&lt;/p&gt;
&lt;p&gt;O exemplo acima testa uma classe simples. Entretanto, poderia testar uma classe mais complexa, como um Handler, que manipula os dados atrav√©s de diversos objetos. Al√©m disso, o service foi criado para n√£o testar as chamadas diretas ao controller.&lt;/p&gt;
&lt;h2 id=&#34;github-actions&#34;&gt;GitHub actions&lt;/h2&gt;
&lt;p&gt;√â poss√≠vel integrar os testes √† pipeline. &lt;a href=&#34;https://www.milanjovanovic.tech/blog/testcontainers-integration-testing-using-docker-in-dotnet&#34;&gt;Essa postagem do Milan Jovanoviƒá&lt;/a&gt; mostra como integr√°-los a uma Github Action:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;name: Run Tests üöÄ

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  run-tests:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: &amp;#39;8.0.x&amp;#39;

      - name: Restore
        run: dotnet restore ./IntegrationTestingDemo.sln

      - name: Build
        run: dotnet build ./IntegrationTestingDemo.sln --no-restore

      - name: Test
        run: dotnet test ./IntegrationTestingDemo.sln --no-build
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;Este √© o fim do tutorial. Espero que esse texto tenha sido o suficiente para te ajudar a implementar testes de integra√ß√£o com TestContainers na sua aplica√ß√£o.&lt;/p&gt;
&lt;p&gt;At√© a pr√≥xima!&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Uma forma simples de realizar soft delete em .Net utilizando Entity Framework Core</title>
      <link>//localhost:1313/posts/dotnet-soft-delete/</link>
      <pubDate>Fri, 19 Jan 2024 12:03:34 -0300</pubDate>
      
      <guid>//localhost:1313/posts/dotnet-soft-delete/</guid>
      <description>&lt;p&gt;Ao desenvolver APIs, √© comum ter de alterar o comportamento de DELETE para que, em vez de excluir o registro, simplesmente alterar uma propriedade booleana e considerar que aquele recurso n√£o existe caso o valor da propriedade seja &lt;em&gt;false&lt;/em&gt;. Essa t√©cnica √© conhecida como &lt;strong&gt;&amp;ldquo;Soft Delete&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;H√° v√°rias formas de implementar esse comportamento. A forma apresentada neste texto pode ser resumida aos seguintes passos:
1- Adicionar uma propriedade booleana √† classe desejada;
2- Sobrescrever o m√©todo &lt;strong&gt;SaveChangesAsync&lt;/strong&gt; da classe que estende &lt;strong&gt;DbContext&lt;/strong&gt;;
3- Adicionar um filtro na configura√ß√£o da entidade para que as entidades &amp;ldquo;inativas&amp;rdquo; n√£o sejam retornadas em queries.&lt;/p&gt;</description>
      <content>&lt;p&gt;Ao desenvolver APIs, √© comum ter de alterar o comportamento de DELETE para que, em vez de excluir o registro, simplesmente alterar uma propriedade booleana e considerar que aquele recurso n√£o existe caso o valor da propriedade seja &lt;em&gt;false&lt;/em&gt;. Essa t√©cnica √© conhecida como &lt;strong&gt;&amp;ldquo;Soft Delete&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;H√° v√°rias formas de implementar esse comportamento. A forma apresentada neste texto pode ser resumida aos seguintes passos:
1- Adicionar uma propriedade booleana √† classe desejada;
2- Sobrescrever o m√©todo &lt;strong&gt;SaveChangesAsync&lt;/strong&gt; da classe que estende &lt;strong&gt;DbContext&lt;/strong&gt;;
3- Adicionar um filtro na configura√ß√£o da entidade para que as entidades &amp;ldquo;inativas&amp;rdquo; n√£o sejam retornadas em queries.&lt;/p&gt;
&lt;h2 id=&#34;adicionar-propriedade-booleana&#34;&gt;Adicionar propriedade booleana&lt;/h2&gt;
&lt;p&gt;O primeiro passo √© autoexplicativo. Crie uma entidade e adicione a propriedade booleana a ela. Caso v√°rias entidades precisem desse comportamento, considere criar uma classe base ou interface que a contenha.&lt;/p&gt;
&lt;h2 id=&#34;sobrescrever-o-m√©todo-savechangesasync&#34;&gt;Sobrescrever o m√©todo SaveChangesAsync&lt;/h2&gt;
&lt;p&gt;Se voc√™ utiliza o EF, √© prov√°vel que tenha estendido a classe &lt;strong&gt;DbContext&lt;/strong&gt; para criar um contexto pr√≥prio. A classe base possui um m√©todo chamado &lt;strong&gt;SaveChangesAsync&lt;/strong&gt;, o qual salva as altera√ß√µes feitas no banco de dados.&lt;br&gt;
A altera√ß√£o que ser√° realizada no m√©todo visa detectar o estado das  entidades rastreadas pelo &lt;a href=&#34;https://learn.microsoft.com/en-us/ef/core/change-tracking/&#34;&gt;ChangeTracker&lt;/a&gt;. Caso alguma tenha sido deletada, ser√° necess√°rio mudar o estado dela para &lt;strong&gt;Unchanged&lt;/strong&gt; (em vez de &lt;strong&gt;Deleted&lt;/strong&gt;), e ent√£o alterar a propriedade booleana adicionada no passo anterior.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public override Task&amp;lt;int&amp;gt; SaveChangesAsync(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default)
{
    foreach (var entry in ChangeTracker.Entries&amp;lt;T&amp;gt;()) // Onde &amp;#34;T&amp;#34; √© o tipo da entidade
    {
        switch (entry.State)
        {
            case EntityState.Deleted:
                entry.State = EntityState.Unchanged;
                entry.Entity.PropriedadeBooleana = false; // Prefira utilizar um m√©todo para isso.
                break;
        }
    }
    return base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;adicionar-filtro&#34;&gt;Adicionar filtro&lt;/h2&gt;
&lt;p&gt;Com a altera√ß√£o feita, j√° √© poss√≠vel alterar todas as queries para que elas deconsiderem entidades √†s quais o valor da propriedade booleana seja &lt;strong&gt;false&lt;/strong&gt;. Entretanto, dependendo do tamanho da sua aplica√ß√£o, essa tarefa poder√° ser bastante trabalhosa.&lt;/p&gt;
&lt;p&gt;Para evitar a situa√ß√£o descrita acima, o EF fornece uma forma de realizar isso de forma autom√°tica atrav√©s da configura√ß√£o da entidade. Exemplo:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class SuaEntidadeConfiguration: IEntityTypeConfiguration&amp;lt;SuaEntidade&amp;gt;
{
    public void Configure(EntityTypeBuilder&amp;lt;SuaEntidade&amp;gt; builder)
    {
        builder.HasQueryFilter(x =&amp;gt; x.Active);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O c√≥digo acima faz com que somente as entidades que possuam a propriedade &lt;strong&gt;Active&lt;/strong&gt; como &lt;strong&gt;true&lt;/strong&gt; sejam retornadas em caso de queries.&lt;/p&gt;
&lt;p&gt;Chegamos ao fim do tutorial. Espero que este texto tenha sido o suficiente para a implementa√ß√£o de um comportamento b√°sico de &lt;strong&gt;Soft delete&lt;/strong&gt; na sua aplica√ß√£o.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Automatizando a cria√ß√£o de requisi√ß√µes no JMeter utilizando Postman</title>
      <link>//localhost:1313/posts/jmeter/</link>
      <pubDate>Mon, 18 Jul 2022 11:49:46 -0300</pubDate>
      
      <guid>//localhost:1313/posts/jmeter/</guid>
      <description>&lt;p&gt;Faz um tempo que n√£o escrevo por aqui, mas hoje, enquanto estudava para resolver um problema do trampo, me deparei com uma t√©cnica que facilitou muito a forma de criar requisi√ß√µes no JMeter, ent√£o decidi compartilh√°-la.&lt;/p&gt;
&lt;p&gt;Antes de mais nada, quero agradecer aos meus amigos &lt;a href=&#34;https://twitter.com/ojuninrocha&#34;&gt;Jurno&lt;/a&gt; e &lt;a href=&#34;https://github.com/poferrari&#34;&gt;Jo√£o&lt;/a&gt;, que me guiaram na busca pela solu√ß√£o.&lt;/p&gt;
&lt;p&gt;Sem mais delongas, bora pro problema.&lt;/p&gt;
&lt;h2 id=&#34;o-problema&#34;&gt;O problema&lt;/h2&gt;
&lt;p&gt;Imagine que em um determinado momento, voc√™ e seu time precisar√£o realizar um teste de carga na aplica√ß√£o que voc√™s desenvolvem. Entretanto, voc√™s possuem pouco ou nenhum conhecimento com a ferramenta JMeter, uma das mais utilizadas para esse tipo de tarefa.
Uma das poss√≠veis solu√ß√µes √© gastar um bom tempo lendo a documenta√ß√£o para aprender a criar as requisi√ß√µes uma a uma. Inclusive, essa teria sido a minha decis√£o, n√£o fosse pelos conselhos dos amigos citados acima.&lt;/p&gt;</description>
      <content>&lt;p&gt;Faz um tempo que n√£o escrevo por aqui, mas hoje, enquanto estudava para resolver um problema do trampo, me deparei com uma t√©cnica que facilitou muito a forma de criar requisi√ß√µes no JMeter, ent√£o decidi compartilh√°-la.&lt;/p&gt;
&lt;p&gt;Antes de mais nada, quero agradecer aos meus amigos &lt;a href=&#34;https://twitter.com/ojuninrocha&#34;&gt;Jurno&lt;/a&gt; e &lt;a href=&#34;https://github.com/poferrari&#34;&gt;Jo√£o&lt;/a&gt;, que me guiaram na busca pela solu√ß√£o.&lt;/p&gt;
&lt;p&gt;Sem mais delongas, bora pro problema.&lt;/p&gt;
&lt;h2 id=&#34;o-problema&#34;&gt;O problema&lt;/h2&gt;
&lt;p&gt;Imagine que em um determinado momento, voc√™ e seu time precisar√£o realizar um teste de carga na aplica√ß√£o que voc√™s desenvolvem. Entretanto, voc√™s possuem pouco ou nenhum conhecimento com a ferramenta JMeter, uma das mais utilizadas para esse tipo de tarefa.
Uma das poss√≠veis solu√ß√µes √© gastar um bom tempo lendo a documenta√ß√£o para aprender a criar as requisi√ß√µes uma a uma. Inclusive, essa teria sido a minha decis√£o, n√£o fosse pelos conselhos dos amigos citados acima.&lt;/p&gt;
&lt;h2 id=&#34;a-solu√ß√£o&#34;&gt;A solu√ß√£o&lt;/h2&gt;
&lt;p&gt;√â poss√≠vel adicionar um elemento ao plano de teste do JMeter chamado &lt;a href=&#34;https://jmeter.apache.org/usermanual/jmeter_proxy_step_by_step.html&#34;&gt;&lt;strong&gt;HTTP(S) Test Script Recorder&lt;/strong&gt;&lt;/a&gt;. Ele √© respons√°vel por gravar requisi√ß√µes http e transform√°-las em uma HTTP Request (sampler).
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6gkliswkgkqjfr4upy0i.png&#34; alt=&#34;Imagem da UI do JMeter mostrando o HTTPS Test Script Recorder&#34;&gt;
Com esse elemento adicionado, basta ajustar as configura√ß√µes de proxy do Postman (ou qualquer outro sistema que voc√™ utiliza) para o endere√ßo do Test Script Recorder (localhost:8888 por default), rodar o elemento e ent√£o realizar uma requisi√ß√£o no sistema a ser testado.
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/rcnltqf07ag0br92nhlv.png&#34; alt=&#34;Configura√ß√µes de proxy do postman&#34;&gt;
Fiz uma requisi√ß√£o de exemplo na &lt;a href=&#34;https://pokeapi.co/api/v2/pokemon/ditto&#34;&gt;Pok√©API&lt;/a&gt;, e eis a requisi√ß√£o montada automaticamente no JMeter:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/29p2sjk2d7iewegegped.png&#34; alt=&#34;Interface do JMeter mostrando a requisi√ß√£o montada automaticamente&#34;&gt;&lt;/p&gt;
&lt;p&gt;√â poss√≠vel que seja necess√°rio realizar algumas altera√ß√µes na requisi√ß√£o gerada, mas creio que o procedimento descrito acima seja um excelente ponto de entrada para requisi√ß√µes mais elaboradas.&lt;/p&gt;
&lt;p&gt;Bem, caso haja alguma d√∫vida sobre o texto ou alguma sugest√£o de melhoria, pe√ßo que envie um coment√°rio üòé.
At√© a pr√≥xima!&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>.Net - Scoped, transient e singleton</title>
      <link>//localhost:1313/posts/lifecycles/</link>
      <pubDate>Tue, 19 Apr 2022 11:47:35 -0300</pubDate>
      
      <guid>//localhost:1313/posts/lifecycles/</guid>
      <description>&lt;p&gt;Vejo bastante gente com dificuldade em entender a diferen√ßa entre os principais tipos de lifecycle quando falamos sobre inje√ß√£o de depend√™ncia em .net. Criei um exemplo no &lt;a href=&#34;https://github.com/lukelima/LifecycleExample.&#34;&gt;GitHub&lt;/a&gt; e vou falar sobre ele.&lt;/p&gt;
&lt;p&gt;Basicamente criei 3 servi√ßos bastante simples e parecidos (apenas para fins did√°ticos) e os injetei utilizando AddSingleton, AddScoped e AddTransient.
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8noxoqf10ivwjukmajcf.png&#34; alt=&#34;Inje√ß√£o dos servi√ßos no arquivo Program.cs&#34;&gt;&lt;/p&gt;
&lt;p&gt;Esses servi√ßos s√≥ possuem uma propriedade, o Id, que √© criada no momento da instancia√ß√£o.
Criei um controller e injetei os servi√ßos por construtor.&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gtxlecy6yja6fdi733us.png&#34; alt=&#34;Inje√ß√£o dos servi√ßos no construtor&#34;&gt;&lt;/p&gt;</description>
      <content>&lt;p&gt;Vejo bastante gente com dificuldade em entender a diferen√ßa entre os principais tipos de lifecycle quando falamos sobre inje√ß√£o de depend√™ncia em .net. Criei um exemplo no &lt;a href=&#34;https://github.com/lukelima/LifecycleExample.&#34;&gt;GitHub&lt;/a&gt; e vou falar sobre ele.&lt;/p&gt;
&lt;p&gt;Basicamente criei 3 servi√ßos bastante simples e parecidos (apenas para fins did√°ticos) e os injetei utilizando AddSingleton, AddScoped e AddTransient.
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8noxoqf10ivwjukmajcf.png&#34; alt=&#34;Inje√ß√£o dos servi√ßos no arquivo Program.cs&#34;&gt;&lt;/p&gt;
&lt;p&gt;Esses servi√ßos s√≥ possuem uma propriedade, o Id, que √© criada no momento da instancia√ß√£o.
Criei um controller e injetei os servi√ßos por construtor.&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gtxlecy6yja6fdi733us.png&#34; alt=&#34;Inje√ß√£o dos servi√ßos no construtor&#34;&gt;&lt;/p&gt;
&lt;p&gt;Tamb√©m injetei uma inst√¢ncia do servi√ßo em cada m√©todo.
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/sbzeyh86fimx3xji9aeu.png&#34; alt=&#34;Inje√ß√£o dos servi√ßos em cada m√©todo&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;singleton&#34;&gt;Singleton&lt;/h2&gt;
&lt;p&gt;O servi√ßo √© criado &lt;strong&gt;uma √∫nica vez&lt;/strong&gt; e a mesma inst√¢ncia √© passada para todas as chamadas dele. Veja que o id, criado no momento da instancia√ß√£o, foi o mesmo (e continua sendo o mesmo independente da requisi√ß√£o):
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/djf0pqcgxgmr0k59iem2.png&#34; alt=&#34;Imagem mostra que uma √∫nica inst√¢ncia foi criada&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;scoped&#34;&gt;Scoped&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Uma √∫nica inst√¢ncia √© criada por requisi√ß√£o&lt;/strong&gt;. Ent√£o se o servi√ßo for chamado em v√°rios lugares em uma √∫nica requisi√ß√£o, a mesma inst√¢ncia ser√° passada. Outras inst√¢ncias ser√£o criadas para as pr√≥ximas requisi√ß√µes.&lt;/p&gt;
&lt;p&gt;Mesma requisi√ß√£o:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wxkot9z4wtnarvh9hvxt.png&#34; alt=&#34;Imagem mostra que uma √∫nica inst√¢ncia foi criada&#34;&gt;&lt;/p&gt;
&lt;p&gt;Requisi√ß√£o diferente:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/tg603oilzwhz3luzoo6h.png&#34; alt=&#34;Imagem mostra que uma nova inst√¢ncia foi criada para uma segunda requisi√ß√£o&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;transient&#34;&gt;Transient&lt;/h2&gt;
&lt;p&gt;Ele √© o mais custoso, pois se o servi√ßo for chamado em diversas classes, &lt;strong&gt;cada uma delas ter√° uma inst√¢ncia diferente&lt;/strong&gt;:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6ynbb4lr6b78cbg1zx5t.png&#34; alt=&#34;Imagem mostra que uma inst√¢ncia foi criada para cada chamada do servi√ßo&#34;&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Testes de unidade com NUnit para aplica√ß√µes C#</title>
      <link>//localhost:1313/posts/dotnet-unit-tests/</link>
      <pubDate>Fri, 18 Mar 2022 11:45:29 -0300</pubDate>
      
      <guid>//localhost:1313/posts/dotnet-unit-tests/</guid>
      <description>&lt;p&gt;Basicamente, testes automatizados s√£o uma forma de automatizar o processo de revis√£o e valida√ß√£o de um software atrav√©s de uma ferramenta program√°vel. Esse processo, que antes podia ser extremamente trabalhoso e demorado, pode ser feito em minutos &amp;ndash; ou at√© mesmo segundos, dependendo dos tipos e da quantidade de testes existentes na sua aplica√ß√£o.&lt;/p&gt;
&lt;p&gt;Mike Cohn criou o conceito de pir√¢mide de testes no livro &amp;ldquo;Succeeding with Agile&amp;rdquo;. √â basicamente uma forma de te fazer pensar nas v√°rias camadas de testes e em como elas devem estar presentes:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/u3ey9qc5peuj6d1jwuby.png&#34; alt=&#34;Pir√¢mide de testes cunhada po Cohn. A base dela √© composta por testes de unidade, seguida por testes de servi√ßos e por fim testes de ui. Quanto mais baixo o n√≠vel do teste na pir√¢mide, mais desacoplado e mais r√°pido ele √©&#34;&gt;
Quanto mais baixo o n√≠vel do teste na pir√¢mide, mais desacoplado e mais r√°pido ele √©, al√©m de mais numeroso.&lt;/p&gt;</description>
      <content>&lt;p&gt;Basicamente, testes automatizados s√£o uma forma de automatizar o processo de revis√£o e valida√ß√£o de um software atrav√©s de uma ferramenta program√°vel. Esse processo, que antes podia ser extremamente trabalhoso e demorado, pode ser feito em minutos &amp;ndash; ou at√© mesmo segundos, dependendo dos tipos e da quantidade de testes existentes na sua aplica√ß√£o.&lt;/p&gt;
&lt;p&gt;Mike Cohn criou o conceito de pir√¢mide de testes no livro &amp;ldquo;Succeeding with Agile&amp;rdquo;. √â basicamente uma forma de te fazer pensar nas v√°rias camadas de testes e em como elas devem estar presentes:
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/u3ey9qc5peuj6d1jwuby.png&#34; alt=&#34;Pir√¢mide de testes cunhada po Cohn. A base dela √© composta por testes de unidade, seguida por testes de servi√ßos e por fim testes de ui. Quanto mais baixo o n√≠vel do teste na pir√¢mide, mais desacoplado e mais r√°pido ele √©&#34;&gt;
Quanto mais baixo o n√≠vel do teste na pir√¢mide, mais desacoplado e mais r√°pido ele √©, al√©m de mais numeroso.&lt;/p&gt;
&lt;p&gt;H√° in√∫meros tipos de teste &amp;ndash; muitos dos quais eu mesmo desconhe√ßo a fundo &amp;ndash; mas abordarei apenas os testes de unidade. Eles possuem esse nome pois tendem as menores unidades de classes e m√©todos de forma isolada do resto da aplica√ß√£o: sem acoplamento, nem nada. Apenas verifica√ß√µes para garantir que eles funcionem conforme o esperado, que as vari√°veis tenham os valores esperados etc.&lt;/p&gt;
&lt;p&gt;Uma disciplina importante para criar testes √© aquela chamada de TDD - Desenvolvimento orientado a testes. Nela, primeiro se escreve os testes, depois o c√≥digo para que o teste funcione, depois o c√≥digo √© refatorado para que se torne a melhor vers√£o que puder ser (esse √∫ltimo passo costuma ser bastante ignorado, gerando d√©bitos t√©cnicos).&lt;/p&gt;
&lt;p&gt;Ok, mas por que come√ßar pelos testes e n√£o pelo c√≥digo ? Porque para criar uma solu√ß√£o, √© necess√°rio saber o que precisa ser criado. √â necess√°rio saber de antem√£o o que uma classe deve fazer, o que um m√©todo deve fazer, o valor que uma vari√°vel deve ter etc. Sem isso em mente, √© muito f√°cil assumir que um resultado qualquer √© o correto. E √© assim que nascem os bugs üêû!&lt;/p&gt;
&lt;p&gt;Sem mais delongas, bora pro c√≥digo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/KGdKKipVBu9vO5hKkb/giphy.gif&#34; alt=&#34;Killjoy do jogo Valorant, em frente a um computador, arrumando os √≥culos no pr√≥prio rosto&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;m√£os-√†-obra&#34;&gt;M√£os √† obra&lt;/h2&gt;
&lt;p&gt;Criei uma aplica√ß√£o console para exemplificar. Nela, criarei uma classe &amp;ldquo;Conta&amp;rdquo; com as seguintes especifica√ß√µes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uma pessoa pode depositar qualquer valor maior que zero na conta;&lt;/li&gt;
&lt;li&gt;Uma pessoa pode sacar valores maiores que 0 e menores ou iguais ao saldo total;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Adicionei um projeto NUnit com o Visual Studio. Nele, criei uma classe chamada &lt;strong&gt;ContaTests&lt;/strong&gt;, conforme abaixo. O atributo &lt;strong&gt;[TestFixture]&lt;/strong&gt; indica que uma classe possui testes.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[TestFixture]
public class ContaTests
{
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;E ent√£o parti para o teste do primeiro m√©todo. Para que um m√©todo seja detectado como teste, √© necess√°rio adicionar o atributo &lt;strong&gt;[Test]&lt;/strong&gt; acima dele. Quanto ao nome do m√©todo de teste, fiz baseando-me em algumas recomenda√ß√µes que podem ser encontradas &lt;a href=&#34;https://docs.microsoft.com/pt-br/dotnet/core/testing/unit-testing-best-practices&#34;&gt;neste link.&lt;/a&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Test]
public void Depositar_RetornaSaldoMaisValorDepositado()
{
    // Arrange 
    
    // Act
    
    // Assert
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gosto de deixar os 3 coment√°rios em todos os testes que crio para separar bem as fases dele. Essas fases formam o padr√£o AAA, muito utilizado na ind√∫stria, e correspondem a:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arrange: fase na qual √© necess√°rio preparar teste preparando as vari√°veis, criando inst√¢ncias de objeto necess√°rias etc.;&lt;/li&gt;
&lt;li&gt;Act: fase na qual o m√©todo a ser testado √© executado;&lt;/li&gt;
&lt;li&gt;Assert: fase na qual √© feita a verifica√ß√£o de que o resultado obtido est√° de acordo com o esperado.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Na primeira fase, criei apenas uma inst√¢ncia da classe &lt;strong&gt;Conta&lt;/strong&gt;, que ainda n√£o existe, e ent√£o criei uma vari√°vel com o valor que espero obter como resultado do teste.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Arrange 
Conta conta = new Conta(&amp;#34;Lucas&amp;#34;, 100);
decimal saldoEsperado = 200;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Na fase de a√ß√£o, executei o m√©todo e armazenei o resultado em uma vari√°vel:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Act
var resultado = conta.Depositar(100);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;E por fim, fiz a verifica√ß√£o de que o resultado era igual ao saldoEsperado. Para isso, usei a classe Assert do NUnit. Ela cont√©m v√°rios m√©todos est√°ticos para testar in√∫meras situa√ß√µes, como listas, igualdades, nulos etc.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Assert
Assert.AreEqual(saldoEsperado, resultado);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O teste final ficou da seguinte forma:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Test]
public void Depositar_RetornaSaldoMaisValorDepositado()
{
    // Arrange 
    Conta conta = new Conta(&amp;#34;Lucas&amp;#34;, 100);
    decimal saldoEsperado = 200;

    Act
    var resultado = conta.Depositar(100);

    Assert
    Assert.AreEqual(saldoEsperado, resultado);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O teste n√£o compilar√° no primeiro momento pois a classe &lt;strong&gt;Conta&lt;/strong&gt; ainda n√£o existe. Logo, decidi cri√°-la:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Conta
{
    public Conta(string cliente, decimal saldo)
    {
        Cliente = cliente;
        Saldo = saldo;
    }

    public string Cliente { get; private set; }
    public decimal Saldo { get; private set; }

    public decimal Depositar(decimal valor)
    {
        Saldo += valor;
        return Saldo;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Aproveitei e tamb√©m criei o m√©todo &lt;strong&gt;Depositar&lt;/strong&gt;. Ele √© simples: recebe um valor e ent√£o adiciona esse valor √† propriedade &lt;strong&gt;Saldo&lt;/strong&gt; da classe.&lt;/p&gt;
&lt;p&gt;Adicionei uma refer√™ncia da classe no projeto de teste e ent√£o o executei. E ent√£o o teste passou !
&lt;img src=&#34;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/h8esevtr3rklh3c27nqa.png&#34; alt=&#34;A imagem mostra que o teste foi aprovado ap√≥s a execu√ß√£o com os valores corretos&#34;&gt;&lt;/p&gt;
&lt;p&gt;‚ö†Ô∏è‚ö†Ô∏è Uma forma de garantir que o teste funciona √© fazendo-o quebrar propositalmente. Uma forma de quebrar o teste acima seria alterando o valor esperado para 300. Se o teste e o c√≥digo estiverem certos, o teste n√£o passar√°. Isso √© importante para evitar que o resultado seja um falso-positivo.‚ö†Ô∏è‚ö†Ô∏è&lt;/p&gt;
&lt;p&gt;Ok, o valor adicionado est√° correto, a soma est√° correta. Mas n√£o √© tudo a ser testado nesse m√©todo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uma pessoa pode depositar qualquer valor &lt;strong&gt;maior que zero&lt;/strong&gt; na conta;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Logo, √© necess√°rio criar um teste para verificar se o meu programa barra o dep√≥sito de um valor negativo como -R$100.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[Test]
public void Deposito_QuandoExecutadoComValorNegativo_LancaLancaInvalidOperationException()
{
    //Arrange
    Conta conta = new Conta(&amp;#34;Lucas&amp;#34;, 100);

    //Act
    Func&amp;lt;decimal&amp;gt; acao = () =&amp;gt; conta.Depositar(-100);

    //Assert
    Assert.Throws&amp;lt;InvalidOperationException&amp;gt;(() =&amp;gt; acao());
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A grande diferen√ßa est√° nas fases &lt;strong&gt;Act&lt;/strong&gt; e &lt;strong&gt;Assert&lt;/strong&gt;. Assim que o valor -100 for detectado pelo m√©todo, √© necess√°rio que ele lance uma nova exce√ß√£o: &lt;strong&gt;InvalidOperationException&lt;/strong&gt;. Quando ela for lan√ßada, o programa sair√° daquele m√©todo antes de complet√°-lo, fazerndo com que o assert seja um pouco diferente. Para testar se ela realmente foi lan√ßada, primeiro armazenei o m√©todo em um delegate (eu poderia explicar o significado mas tanto a &lt;a href=&#34;https://docs.microsoft.com/pt-br/dotnet/api/system.delegate?view=net-6.0&#34;&gt;Microsoft&lt;/a&gt; quanto o &lt;a href=&#34;http://www.macoratti.net/17/01/net_deleg1.htm&#34;&gt;Macoratti&lt;/a&gt; fizeram um excelente trabalho falando sobre) e ent√£o utilizei o m√©todo Throws da classe Assert. Ele recebe o tipo da exce√ß√£o como generic (&lt;a href=&#34;https://docs.microsoft.com/pt-br/dotnet/standard/generics/&#34;&gt;artigo da Microsoft&lt;/a&gt; e &lt;a href=&#34;http://www.macoratti.net/11/07/net_gen1.htm&#34;&gt;artigo do Macoratti&lt;/a&gt;) e ent√£o consegue verificar se a exce√ß√£o foi lan√ßada.&lt;/p&gt;
&lt;p&gt;Ao rodar o teste na primeira vez, ele n√£o passoupois o m√©todo ainda n√£o lan√ßa a exce√ß√£o. Adicionei apenas 1 if para lan√ßar a exce√ß√£o e ent√£o o teste passou !&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public decimal Depositar(decimal valor)
{
    if (valor &amp;lt;= 0)
    {
        throw new InvalidOperationException(&amp;#34;N√£o √© poss√≠vel depositar valores negativos&amp;#34;);
    }
    Saldo += valor;
    return Saldo
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;‚ö†Ô∏è‚ö†Ô∏èPara quebrar o teste e verificar se ele n√£o d√° um falso positivo, √© poss√≠vel simplesmente alterar o tipo da exce√ß√£o esperada no Assert.‚ö†Ô∏è‚ö†Ô∏è&lt;/p&gt;
&lt;p&gt;Por se tratar de um exemplo, o m√©todo de saque ter√° testes bastante parecidos com o do dep√≥sito, ent√£o √© poss√≠vel verific√°-lo, assim como todo o resto do c√≥digo, nesse reposit√≥rio do GitHub que criei!&lt;/p&gt;
&lt;p&gt;Bem, essa foi uma breve introdu√ß√£o sobre testes de unidade. Na pr√≥xima parte falarei sobre &lt;strong&gt;Mocks&lt;/strong&gt; em um exemplo de uma API Rest e sobre o m√©todo &lt;strong&gt;SetUp&lt;/strong&gt;.Se curtiu, n√£o esque√ßa de compartilhar a postagem!&lt;/p&gt;
&lt;p&gt;At√© a pr√≥xima !&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/2YgCmRh9Arduw8LshF/giphy.gif&#34; alt=&#34;Snoopy Dogg acenando em despedida&#34;&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Como usar Redis em uma solu√ß√£o .Net</title>
      <link>//localhost:1313/posts/dotnet-redis/</link>
      <pubDate>Mon, 29 Nov 2021 11:41:55 -0300</pubDate>
      
      <guid>//localhost:1313/posts/dotnet-redis/</guid>
      <description>&lt;p&gt;Ol√°!&lt;/p&gt;
&lt;p&gt;Faz algum tempo que n√£o escrevo por aqui mas senti saudades disso. Desde que escrevi meu √∫ltimo artigo grande (&lt;a href=&#34;https://dev.to/cephalopodluke/introducao-a-programacao-com-dart-aji&#34;&gt;uma introdu√ß√£o sobre flutter&lt;/a&gt;), comecei a trabalhar com .Net e C#. √â poss√≠vel ver algumas semelhan√ßas em ambas linguagens e isso facilitou bastante meu aprendizado nela.&lt;/p&gt;
&lt;p&gt;Bem, tenho desenvolvido algumas APIs e trabalhado com alguns problemas envolvendo implanta√ß√µes de aplica√ß√µes, bem coisa de backend mesmo. Um dos primeiros problemas que precisei resolver foi implementar uma forma de uso de cache utilizando Redis em uma API.&lt;/p&gt;</description>
      <content>&lt;p&gt;Ol√°!&lt;/p&gt;
&lt;p&gt;Faz algum tempo que n√£o escrevo por aqui mas senti saudades disso. Desde que escrevi meu √∫ltimo artigo grande (&lt;a href=&#34;https://dev.to/cephalopodluke/introducao-a-programacao-com-dart-aji&#34;&gt;uma introdu√ß√£o sobre flutter&lt;/a&gt;), comecei a trabalhar com .Net e C#. √â poss√≠vel ver algumas semelhan√ßas em ambas linguagens e isso facilitou bastante meu aprendizado nela.&lt;/p&gt;
&lt;p&gt;Bem, tenho desenvolvido algumas APIs e trabalhado com alguns problemas envolvendo implanta√ß√µes de aplica√ß√µes, bem coisa de backend mesmo. Um dos primeiros problemas que precisei resolver foi implementar uma forma de uso de cache utilizando Redis em uma API.&lt;/p&gt;
&lt;p&gt;Apenas para esclarecimento, cache √© um local de armazenamento de dados tempor√°rios que servir√£o para ajudar aplica√ß√µes web, mobile etc. Implementar cache na sua solu√ß√£o pode trazer diversos benef√≠cios como economizar banda, reduzir tempo de resposta, realizar menos chamadas ao banco em alguns casos espec√≠ficos etc. Entretanto tamb√©m pode causar in√∫meros problemas. Um deles √© o de os dados n√£o estarem mais atualizados em solu√ß√µes que esses dados mudam frequentemente.&lt;/p&gt;
&lt;p&gt;Criei um c√≥digo para esse artigo que pode ser encontrado &lt;a href=&#34;https://github.com/lukelima/ExemploRedis&#34;&gt;nesse reposit√≥rio do GitHub&lt;/a&gt;. Nele, criei consumi a &lt;a href=&#34;https://pokeapi.co/&#34;&gt;Pok√©Api&lt;/a&gt;, uma API com dados de quase todos os pok√©mons lan√ßados at√© hoje. Segui a pol√≠tica de fair use dela que diz &lt;em&gt;&amp;ldquo;Locally cache resources whenever you request them.&amp;rdquo;&lt;/em&gt; (armazene recursos em cache quando os consultar) e salvei todas as requisi√ß√µes em cache por um tempo limitado.&lt;/p&gt;
&lt;p&gt;A estrutura de pastas do projeto ficou da seguinte forma:za&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExemploRedis/
‚îú‚îÄ Controllers/
‚îÇ  ‚îú‚îÄ PokemonController.cs
‚îú‚îÄ Extensions/
‚îÇ  ‚îú‚îÄ DistributedCacheExtension.cs
‚îú‚îÄ Services/
‚îÇ  ‚îú‚îÄ Interfaces/
‚îÇ  ‚îÇ  ‚îú‚îÄ ICacheService.cs
‚îÇ  ‚îÇ  ‚îú‚îÄ IPokemonService.cs
‚îÇ  ‚îú‚îÄ PokemonCacheService.cs
‚îÇ  ‚îú‚îÄ PokemonService.cs
‚îú‚îÄ Pokemon.cs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O arquivo &lt;strong&gt;Pokemon.cs&lt;/strong&gt; cont√©m as informa√ß√µes de Pok√©mons da API. Para a simplicidade do exemplo, adicionei apenas 3 propriedades:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class Pokemon
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Weight { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Adicionei o pacote &lt;strong&gt;Microsoft.Extensions.Caching.Redis&lt;/strong&gt; NuGet para trabalhar com o Redis. Com ele, criei a extens√£o &lt;strong&gt;Extensions/DistributedCacheExtension.cs&lt;/strong&gt; para adicionar o servi√ßo √† API:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public static IServiceCollection AddDistributedCache(
    this IServiceCollection services,
    IConfiguration configuration)
{
    services.AddDistributedRedisCache(options =&amp;gt;
    {
        options.Configuration = 
            configuration.GetConnectionString(&amp;#34;Redis&amp;#34;);
        options.InstanceName = 
            configuration[&amp;#34;Redis:InstanceName&amp;#34;];
    });
    return services;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As options da configura√ß√£o s√£o autoexplicativas: string de conex√£o ao servi√ßo e nome da inst√¢ncia.
Adicionei essa extens√£o no arquivo Startup.cs, no m√©todo &lt;strong&gt;ConfigureServices&lt;/strong&gt;, com a seguinte linha de c√≥digo:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;services.AddDistributedCache(Configuration);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Com o Redis configurado, desenvolvi um servi√ßo que me auxiliaria a buscar e adicionar dados a ele visando evitar repeti√ß√£o de c√≥digo.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public interface ICacheService&amp;lt;T&amp;gt;
{
    Task&amp;lt;T&amp;gt; Get(int id);
    Task Set(T content);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O c√≥digo acima √© da interface do servi√ßo. Decidi usar um tipo gen√©rico nela para que ela seja reaproveitada para qualquer objeto que eu precisar. O servi√ßo que a implementa ficou assim:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class PokemonCacheService : ICacheService&amp;lt;Pokemon&amp;gt;
{
    private readonly IDistributedCache _distributedCache;
    private readonly DistributedCacheEntryOptions _options;
    private const string Prefix = &amp;#34;pokemon_&amp;#34;;

    public PokemonCacheService(IDistributedCache distributedCache)
    {
        _distributedCache = distributedCache;
        _options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = 
                TimeSpan.FromSeconds(120),
            SlidingExpiration = TimeSpan.FromSeconds(60)
        };
    }

    public async Task&amp;lt;Pokemon&amp;gt; Get(int id)
    {
        var key = Prefix + id;
        var cache = await _distributedCache.GetStringAsync(key);
        if (cache is null)
        {
            return null;
        }
        var pokemon = JsonConvert.DeserializeObject&amp;lt;Pokemon&amp;gt; 
            (cache);
        return pokemon;
    }

    public async Task Set(Pokemon content)
    {
        var key = Prefix + content.Id;
        var pokemonString = JsonConvert.SerializeObject(content);
        await _distributedCache.SetStringAsync(key, pokemonString, 
            _options);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Passando por todos os pontos:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private readonly IDistributedCache _distributedCache;
private readonly DistributedCacheEntryOptions _options;
private const string Prefix = &amp;#34;pokemon_&amp;#34;;

public PokemonCacheService(IDistributedCache distributedCache)
{
    _distributedCache = distributedCache;
    _options = new DistributedCacheEntryOptions
    {
        AbsoluteExpirationRelativeToNow =   
            TimeSpan.FromSeconds(120),
        SlidingExpiration = TimeSpan.FromSeconds(60)
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Os dois primeiros campos, &lt;strong&gt;_distributedCache&lt;/strong&gt; e &lt;strong&gt;_options&lt;/strong&gt; est√£o relacionados diretamente √† configura√ß√£o do Redis. &lt;strong&gt;IDistributedCache&lt;/strong&gt; √© a interface que utilizei para acessar o Redis atrav√©s de inje√ß√£o de depend√™ncia. J√° &lt;strong&gt;DistributedCacheEntryOptions&lt;/strong&gt; √© a classe respons√°vel por configurar op√ß√µes como &lt;strong&gt;AbsoluteExpirationRelativeToNow&lt;/strong&gt; e &lt;strong&gt;SlidingExpiration&lt;/strong&gt;, que referem-se ao tempo total que um dado ficar√° armazenado e ao tempo que ele pode ficar armazenado sem ser consultado (nunca maior que o tempo absoluto), respectivamente. &lt;strong&gt;Prefix&lt;/strong&gt; refere-se ao prefixo que utilizo para armazenar os pokemons. Utilizo ele + o id do pokemon para armazenar os dados com chaves √∫nicas &amp;ndash; o que facilita a consulta posterior.&lt;/p&gt;
&lt;p&gt;Sobre o m√©todo Get:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public async Task&amp;lt;Pokemon&amp;gt; Get(int id)
{
    var key = Prefix + id;
    var cache = await _distributedCache.GetStringAsync(key);
    if (cache is null)
    {
        return null;
    }
    var pokemon = JsonConvert.DeserializeObject&amp;lt;Pokemon&amp;gt;(cache);
    return pokemon;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nele, crio a chave como prefixo + id do pokemon e busco o dado no cache utilizando o m√©todo &lt;strong&gt;GetStringAsync(key)&lt;/strong&gt; da interface IDistributedCache. Se ele for nulo, retorno nulo (ou poderia notificar um erro ou lan√ßar uma exce√ß√£o). Caso o contr√°rio, deserializo a string obtida em pokemon e retorno o valor.&lt;/p&gt;
&lt;p&gt;Sobre o m√©todo Set:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public async Task Set(Pokemon content)
{
    var key = Prefix + content.Id;
    var pokemonString = JsonConvert.SerializeObject(content);
    await _distributedCache.SetStringAsync(key, pokemonString, 
        _options);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nele, crio a chave da mesma forma, com o prefixo + o id do pokemon informado, ent√£o serializo o objeto em string e armazeno no Redis utilizando o m√©todo &lt;strong&gt;SetStringAsync()&lt;/strong&gt; da interface IDistributedCache. Esse m√©todo recebe a chave que ser√° utilizada para armazenamento (a mesma a ser consultada depois), o dado que ser√° armazenado e as op√ß√µes de armazenamento (lembra que configurei a expira√ß√£o dos dados no construtor ? Pois bem, √© aqui que informo essa configura√ß√£o).&lt;/p&gt;
&lt;p&gt;Com o servi√ßo de cache pronto, desenvolvi o servi√ßo de consulta √† Pok√©Api. Interface:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public interface IPokemonService
{
    Task&amp;lt;Pokemon&amp;gt; GetPokemon(int id);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;E o servi√ßo que a implementa:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class PokemonService : IPokemonService
{
    private readonly HttpClient _httpClient;

    public PokemonService(HttpClient httpClient)
    {
        _httpClient = httpClient;
        _httpClient.BaseAddress = new 
            Uri(&amp;#34;https://pokeapi.co/api/v2/&amp;#34;);
    }

    public async Task&amp;lt;Pokemon&amp;gt; GetPokemon(int id)
    {
        var response = await 
            _httpClient.GetAsync($&amp;#34;pokemon/{id}&amp;#34;);
        var content = await response.Content.ReadAsStringAsync();
        var pokemon = JsonConvert.DeserializeObject&amp;lt;Pokemon&amp;gt; 
            (content);
        return pokemon;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;O servi√ßo √© bem simples: possui um campo HttpClient que foi injetado e o m√©todo GetPokemon(int id), que faz a chamada √† API e retorna um pok√©mon. Adicionei o HttpClient ao startup utilizando a seguinte linha de c√≥digo no arquivo &lt;strong&gt;Startup.cs&lt;/strong&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    services.AddHttpClient&amp;lt;IPokemonService, PokemonService&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;√â importante notar que esse m√©todo adiciona tanto o client como o servi√ßo a ser injetado por depend√™ncia.&lt;/p&gt;
&lt;p&gt;Com tudo pronto, criei um controller para servir esses dados:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[ApiController]
[Route(&amp;#34;api/[controller]&amp;#34;)]
public class PokemonController : ControllerBase
{
    private readonly IPokemonService _pokemonService;
    private readonly ICacheService&amp;lt;Pokemon&amp;gt; _pokemonCacheService;

    public PokemonController(IPokemonService pokemonService, 
        ICacheService&amp;lt;Pokemon&amp;gt; pokemonCacheService)
    {
        _pokemonService = pokemonService;
        _pokemonCacheService = pokemonCacheService;
    }

    [HttpGet(&amp;#34;{id}&amp;#34;)]
    public async Task&amp;lt;IActionResult&amp;gt; Get(int id)
    {
        Pokemon pokemon = await _pokemonCacheService.Get(id);
        if (pokemon is null)
        {
            pokemon = await _pokemonService.GetPokemon(id);
            await _pokemonCacheService.Set(pokemon);
        }
        return Ok(pokemon);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nele, injeto tanto o PokemonService quanto o CacheService pelo construtor. Como essa Api faz apenas a pesquisa de pokemons, o controller possui apenas 1 m√©todo: Get. Ele recebe um id na rota, ent√£o verifica se h√° no cache um pokemon com esse id. Se houver, ele retorna o pok√©mon. Caso n√£o haja, ele chama o service que consultar√° a API e ent√£o devolve o pok√©mon.&lt;/p&gt;
&lt;p&gt;E esse √© o fim do tutorial. Lembre-se de baixar o reposit√≥rio no &lt;a href=&#34;https://github.com/lukelima/ExemploRedis&#34;&gt;GitHub&lt;/a&gt; caso queira estud√°-lo melhor. Caso queira, deixei um arquivo docker-compose.yml para facilitar o uso do Redis.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
